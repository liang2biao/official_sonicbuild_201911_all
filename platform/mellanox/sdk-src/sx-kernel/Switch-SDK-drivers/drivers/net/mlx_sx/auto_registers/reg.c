/*
* Copyright (c) 2010-2018,  Mellanox Technologies. All rights reserve
*
* This software is available to you under a choice of one of two
* licenses.  You may choose to be licensed under the terms of the GNU
* General Public License (GPL) Version 2, available from the file
* COPYING in the main directory of this source tree, or the
* OpenIB.org BSD license below:
*
*     Redistribution and use in source and binary forms, with or
*     without modification, are permitted provided that the following
*     conditions are met:
*
*      - Redistributions of source code must retain the above
*        copyright notice, this list of conditions and the following
*        disclaimer.
*
*      - Redistributions in binary form must reproduce the above
*        copyright notice, this list of conditions and the following
*        disclaimer in the documentation and/or other materials
*        provided with the distribution.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

/*
 * THIS FILE IS AUTO GENERATED.
 * DO NOT MAKE ANY CHANGES!
 * They will be erased with next update.
 *
 * Date: 2019-08-05 14:12
 * ADABE PRM Version: Rev 1.55.004
 * Generated by adb_to_sxd.py (A-ME Version: a-me-1.0.123_2019-08-04)
 *
 */

#include <linux/string.h>
#include <stdbool.h>
#include <linux/mlx_sx/auto_registers/mlxsw_item.h>
#include <linux/mlx_sx/auto_registers/reg.h>

/************************************************
 *  Global variables
 ***********************************************/


/************************************************
 *  Local variables
 ***********************************************/

/************************************************
 *  Local function declarations
 ***********************************************/


/************************************************
 *  Function implementations
 ***********************************************/
/* pecnrr
 * ------
 *
 */
/* clear
 * Clear counters
 * Access: OP
 */
MLXSW_ITEM8(reg, pecnrr, clear, 0x0, 7, 1);

/* tcam_trigger_high
 * Count number of tcam triggers (bind to ACL group)
 * For example: if a packet has iACL and eirfACL then inc by 2
 * Access: RO
 */
MLXSW_ITEM32(reg, pecnrr, tcam_trigger_high, 0x10, 0, 32);

/* tcam_trigger_low
 * Count number of tcam triggers (bind to ACL group)
 * For example: if a packet has iACL and eirfACL then inc by 2
 * Access: RO
 */
MLXSW_ITEM32(reg, pecnrr, tcam_trigger_low, 0x14, 0, 32);

/* tcam_full_lookup_high
 * Count number of tcam triggers which needed a full lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecnrr, tcam_full_lookup_high, 0x18, 0, 32);

/* tcam_full_lookup_low
 * Count number of tcam triggers which needed a full lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecnrr, tcam_full_lookup_low, 0x1c, 0, 32);

/* paos
 * ----
 *
 */
/* swid
 * For HCA: must always be 0.
 * Switch partition ID with which to associate the port.
 * Switch partitions are numbered from 0 to 7 inclusively.
 * The 
 * swid
 *  field is only valid when the 
 * local_port
 *  is the router port. 
 * In this case, the 
 * swid
 *  indicates which of the router ports to config
 * ure/query.
 * Access: INDEX
 */
MLXSW_ITEM8(reg, paos, swid, 0x0, 0, 8);

/* local_port
 * Local port number.
 * Access: INDEX
 */
MLXSW_ITEM8(reg, paos, local_port, 0x1, 0, 8);

/* pnat
 * Port number access type. determines the way 
 * local_port
 *  
 * is inter
 * preted:
 * 0: Local_port_number
 * 1: Label_port_number
 * 3: Out_of_band_or_PCI
 * Access: INDEX
 */
MLXSW_ITEM8(reg, paos, pnat, 0x2, 6, 2);

/* admin_status
 * Port administrative state (the desired state of the interface):
 * 1: up
 * 2: down_by_configuration
 * 3: up_once - if the port goes up and then down, the operational 
 * status should go to "down by port failure" and can only go back 
 * up upon explicit command
 * 4: disabled_by_system - this mode cannot be set by the software, 
 * only by the hardware.
 * Access: RW
 */
MLXSW_ITEM8(reg, paos, admin_status, 0x2, 0, 4);

/* oper_status
 * Port operational state:
 * 1: up
 * 2: down
 * 4: down_by_port_failure - (transitioned by the hardware)
 * Access: RO
 */
MLXSW_ITEM8(reg, paos, oper_status, 0x3, 0, 4);

/* ase
 * Admin state update enable. If this bit is set, admin state will be 
 * updated based on 
 * admin_state
 *  field. Only relevant on Set() opera
 * tions.
 * Access: WO
 */
MLXSW_ITEM8(reg, paos, ase, 0x4, 7, 1);

/* ee
 * Event update enable. If this bit is set, event generation will be 
 * updated based on the 
 * e
 *  field. Only relevant on Set operations.
 * Not Supported for HCA.
 * Access: WO
 */
MLXSW_ITEM8(reg, paos, ee, 0x4, 6, 1);

/* e
 * Event generation on operational state change:
 * 0: Do_not_generate_event
 * 1: Generate_Event 
 * 2: Generate_Single_Event
 * Not Supported for HCA.
 * Access: RW
 */
MLXSW_ITEM8(reg, paos, e, 0x7, 0, 2);

/* mtutc
 * -----
 *
 */
/* operation
 * Operation:
 * 0: SET_TIME_AT_NEXT_SEC - the 
 * utc_sec
 *  will be sampled at 
 * the next PPS (of either 
 * virtual_pin
 *  or hw_utc_nsec wrap around)
 * 1: SET_TIME_IMMEDIATE - reserved when Spectrum-1
 * 2: ADJUST_TIME
 * 3: ADJUST_FREQ
 * Access: OP
 */
MLXSW_ITEM8(reg, mtutc, operation, 0x3, 0, 4);

/* freq_adjustment
 * Frequency adjustment: Every PPS the HW frequency will be 
 * adjusted by this value. Units of HW clock, where HW counts 
 * 10^9 HW clocks for 1 HW second.
 * Updated when operation is ADJUST_FREQ
 * Access: RW
 */
MLXSW_ITEM32(reg, mtutc, freq_adjustment, 0x4, 0, 32);

/* utc_sec
 * UTC seconds
 * Updated when operation is SET_TIME_IMMEDIATE or at next 
 * PPS when operation is SET_TIME_AT_NEXT_SEC
 * Access: WO
 */
MLXSW_ITEM32(reg, mtutc, utc_sec, 0x10, 0, 32);

/* utc_nsec
 * UTC nSecs
 * Range 0..(10^9-1)
 * Updated when operation is SET_TIME_IMMEDIATE
 * Reserved when Spectrum-1
 * Access: WO
 */
MLXSW_ITEM32(reg, mtutc, utc_nsec, 0x14, 0, 30);

/* time_adjustment
 * Time adjustment
 * Units of nSec
 * Range is from -32768 to +32767
 * Reserved when Spectrum-1
 * Access: WO
 */
MLXSW_ITEM32(reg, mtutc, time_adjustment, 0x18, 0, 32);

/* sfmr
 * ----
 *
 */
/* op
 * Operation
 * 0: FID is valid
 * 1: FID is not valid
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, op, 0x0, 0, 4);

/* fid
 * Filtering Identifier
 * Also supported for values of 0..4K-1
 * Access: INDEX
 */
MLXSW_ITEM16(reg, sfmr, fid, 0x2, 0, 16);

/* flood_rsp
 * Router sub-port flooding tables:
 * 0: regular flooding tables
 * 1: router sub-port flooding table, for this fid the flooding is 
 * per router-sub-port local_port. Must not be set for a fid which 
 * is not a router-sub-port. 
 * Note: must be set prior to enabling the relevant RIF!
 * Reserved when 
 * ubridge
 *  = 0
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, flood_rsp, 0x8, 7, 1);

/* flood_bridge_type
 * Flood bridge type (see SFGC.
 * bridge_type
 * ):
 * 0: type_0
 * 1: type_1
 * Reserved when 
 * ubridge
 *  = 0
 * Reserved when 
 * flood_rsp
 *  = 1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, flood_bridge_type, 0x8, 4, 1);

/* fid_offset
 * FID Offset
 * Used to point into the flooding table selected by SFGC regis
 * ter if the table is of type FID-Offset. 
 * For other flooding table types, this field is reserved.
 * Reserved when 
 * op
 *  = 1
 * Reserved when 
 * flood_rsp
 *  = 1
 * Access: RW
 */
MLXSW_ITEM16(reg, sfmr, fid_offset, 0xa, 0, 16);

/* vtfp
 * Tunnel Flood Pointer Valid
 * If it is not set, 
 * nve_tunnel_flood_ptr
 *  is reserved and is con
 * sidered as NULL pointer.
 * For Spectrum
 *  when ubridge=0 and 802.1Q FIDs - reserved 
 * Reserved when 
 * op
 *  = 1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, vtfp, 0xc, 7, 1);

/* nve_tunnel_flood_ptr
 * Underlay Flooding and BC Pointer. Used as a pointer to the 
 * first entry of the group based link lists of flooding or BC 
 * entries (for NVE tunnels). The number of link lists in the 
 * group is configured by TNGCR.
 * nve_hash_size_flood
 * , see 
 * Section 15.11.1, "
 * TNGCR - Tunneling NVE General Config
 * uration Register
 * ," on page 2046
 * The pointer points to entries which are configured by 
 * TNUMT, see 
 * Section 15.11.5, "
 * TNUMT - Tunneling NVE 
 * Underlay Multicast Table Register
 * ," on page 2055
 * .
 * For Spectrum/-2, this points to an entry in the KVD Linear, 
 * see 
 * Appendix A.3.1.2, "
 * KVD Central Database Linear 
 * Entries
 * " (page 2169)
 * Reserved when 
 * op
 *  = 1
 * Access: RW
 */
MLXSW_ITEM32(reg, sfmr, nve_tunnel_flood_ptr, 0xc, 0, 24);

/* vv
 * VNI Valid.
 * If it is not set, 
 * vni
 *  is reserved
 * Reserved when 
 * op
 *  = 1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, vv, 0x10, 7, 1);

/* vni
 * Virtual Network Identifier
 * SW must not assign a given VNI to more than one FID
 * Reserved when 
 * op
 *  = 1
 * Reserved when 
 * vv
 *  = 0
 * Range 0.. (2^24-2)
 * Access: RW
 */
MLXSW_ITEM32(reg, sfmr, vni, 0x10, 0, 24);

/* irif_v
 * Ingress RIF valid:
 * 0: irif is not valid, no irif assigned
 * 1: irif valid
 * Must not be set for a non valid RIF
 * Reserved when 
 * ubridge 
 * = 0
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, irif_v, 0x14, 0, 1);

/* irif
 * Ingress RIF (Router Interface)
 * Range is 0.. 
 * cap_max_router_interfaces
 * -1
 * Reserved when 
 * ubridge 
 * = 0
 * Reserved when 
 * irif_v 
 * = 0
 * Access: RW
 */
MLXSW_ITEM16(reg, sfmr, irif, 0x16, 0, 16);

/* decap_counter_set_type
 * Counter Set Type for flow counters.
 * Counts NVE Decap from vni to fid
 * For Spectrum/-2: See 
 * Section 4.2.2, "
 * Counter Set Type
 * ," on 
 * page 588
 * Not supported by SwitchX/-2
 * Reserved when 
 * ubridge
 * =1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, decap_counter_set_type, 0x18, 0, 8);

/* decap_counter_index
 * Counter Index for flow counters.
 * Counts NVE Decap from vni to fid
 * For Spectrum/-2: See 
 * Section 4.1, "
 * Performance and Moni
 * toring Counters
 * ," on page 587
 * Not supported by SwitchX/-2
 * Reserved when 
 * ubridge
 * =1
 * Access: RW
 */
MLXSW_ITEM32(reg, sfmr, decap_counter_index, 0x18, 0, 24);

/* smpe_valid
 * SMPE is valid
 * Reserved when 
 * ubridge 
 * = 0
 * Reserved when 
 * flood_rsp
 *  = 1
 * Reserved when SwitchX/-2 or when Spectrum-1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfmr, smpe_valid, 0x29, 4, 1);

/* smpe
 * Switch multicast port to egress VID
 * Range is 0.. 
 * cap_max_rmpe
 *  - 1
 * Reserved when 
 * ubridge 
 * = 0
 * Reserved when 
 * flood_rsp
 *  = 1
 * Reserved when SwitxcX/-2 or when Spectrum-1
 * Access: RW
 */
MLXSW_ITEM16(reg, sfmr, smpe, 0x2a, 0, 16);

/* ptcead
 * ------
 *
 */
/* op
 * 0: Read activity
 * 1: Read and clear activity
 * Access: OP
 */
MLXSW_ITEM8(reg, ptcead, op, 0x0, 6, 2);

/* offset
 * Offset within the multicast forwarding table
 * Must be N*32
 * Access: INDEX
 */
MLXSW_ITEM16(reg, ptcead, offset, 0x2, 0, 16);

/* num_rec
 * Number of records to read
 * Range 1..4096
 * Access: OP
 */
MLXSW_ITEM16(reg, ptcead, num_rec, 0x6, 0, 13);

/* tcam_region_info
 * Opaque object that represents the TCAM region.
 * See 
 * Table 1589, "tcam_region_info Layout," on page 1620
 * Access: INDEX
 */
MLXSW_ITEM_BUF(reg, ptcead, tcam_region_info, 0x10, 16);

/* activity_vector
 * Activity per offset
 * Line 20h bit 31 is for entry 
 * offset+
 * 4095
 * Line 21C bit 0 is for entry 
 * offset+
 * 0
 * Bits higher than 
 * num_rec 
 * are reserved
 * Bits higher than region_size
 *  
 * are reserved
 * For non-valid offsets the activity is reserved
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, ptcead, activity_vector, 0x20, 0, 32, 4, 0, false);

/* rips
 * ----
 *
 */
/* index
 * Index to IPv6 address
 * For Spectrum, the index is to the KVD linear, see 
 * Section A.3.1, 
 * "
 * KVD Central Database
 * ," on page 2166
 * Access: INDEX
 */
MLXSW_ITEM32(reg, rips, index, 0x0, 0, 24);

/* ipv6
 * IPv6 address
 * Access: RW
 */
MLXSW_ITEM32_INDEXED(reg, rips, ipv6, 0x4, 0, 32, 4, 0, false);

/* tnpc
 * ----
 *
 */
/* learn_enable_v4
 * When decap:
 * Enable learning from tunnel port for IPv4 packets
 * Access: RW
 */
MLXSW_ITEM8(reg, tnpc, learn_enable_v4, 0x7, 0, 1);

/* pecnre
 * ------
 *
 */
/* region_id
 * Region identifier
 * Range 0 .. 
 * cap_max_regions
 * -1
 * Note: the counter (PECNRR) is always enabled. It is suggested 
 * to clear the counter (PECNRR.
 * clear
 * ) after changing the 
 * region_id
 * Access: RW
 */
MLXSW_ITEM16(reg, pecnre, region_id, 0xa, 0, 16);

/* region_id_mask
 * Region_id mask
 * Per bit:
 * 0: ignore 
 * region_id
 *  relevant bit
 * 1: compare 
 * region_id
 *  relevant bit
 * Can be used for a binary search on regions with high count val
 * ues
 * Note: value of all '0' is not supported 
 * Range 0 .. 2^ (round_down(log2(
 * cap_max_regions
 * -1)) + 1)
 * Access: RW
 */
MLXSW_ITEM16(reg, pecnre, region_id_mask, 0xe, 0, 16);

/* pemrbt
 * ------
 *
 */
/* protocol
 * Protocol:
 * 0: IPv4
 * 1: IPv6
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pemrbt, protocol, 0x3, 0, 1);

/* group_id
 * ACL group identifier (
 * acl_group_id)
 * Range of group id is 0..
 * cap_max_acl_groups
 * -1
 * Note: the 
 * group_id
 *  must be configured prior to enabling mc router
 * Access: RW
 */
MLXSW_ITEM16(reg, pemrbt, group_id, 0x12, 0, 16);

/* mpcir
 * -----
 *
 */
/* all
 * If set to '01', activates the flow of preparation for FW ISSU, on all 
 * services. The values in op-codes for "per-service" are ignored.
 * If set to '10', returns to operational state on all services. The val
 * ues in op-codes for "per-service" are ignored.
 * 11 - Reserved
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, all, 0x0, 6, 2);

/* gearbox
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, gearbox, 0x5, 0, 2);

/* leds
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, leds, 0x6, 6, 2);

/* voltage_current
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, voltage_current, 0x6, 4, 2);

/* power
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, power, 0x6, 2, 2);

/* fans
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, fans, 0x6, 0, 2);

/* thermal
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, thermal, 0x7, 6, 2);

/* module_mng
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, module_mng, 0x7, 4, 2);

/* cpld
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, cpld, 0x7, 2, 2);

/* ports
 * For each of the services, the following operations are available:
 * 0: N/A (no action)
 * 1: start preparation flow for FW ISSU 
 * 2: return to operational service (end of FW ISSU flow)
 * 3: get status
 * When set to '3', the current status will appear in corresponding 
 * _stat 
 * fields.
 * Access: OP
 */
MLXSW_ITEM8(reg, mpcir, ports, 0x7, 0, 2);

/* gearbox_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, gearbox_stat, 0xd, 0, 2);

/* leds_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, leds_stat, 0xe, 6, 2);

/* voltage_current_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, voltage_current_stat, 0xe, 4, 2);

/* power_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, power_stat, 0xe, 2, 2);

/* fans_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, fans_stat, 0xe, 0, 2);

/* thermal_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, thermal_stat, 0xf, 6, 2);

/* module_mng_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, module_mng_stat, 0xf, 4, 2);

/* cpld_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, cpld_stat, 0xf, 2, 2);

/* ports_stat
 * Status for each of the services. 
 * 0: not in FW ISSU flow state (FW ISSU flow is not initiated) 
 * 1: done with preparations for FW ISSU flow
 * 2: Preparation for FW ISSU flow started but FW still not done ser
 * vice handling
 *  [Internal]: busy with some other critical flow)
 * .
 * For not implemented services on a particular system, the status 
 * should be '1'.
 * Access: RO
 */
MLXSW_ITEM8(reg, mpcir, ports_stat, 0xf, 0, 2);

/* ralcm
 * -----
 *
 */
/* virtual_router
 * Virtual Router ID
 * Range is 0..
 * cap_max_virtual_routers
 *  -1
 * Access: INDEX
 */
MLXSW_ITEM16(reg, ralcm, virtual_router, 0x0, 0, 16);

/* protocol
 * Protocol:
 * 0: Unicast IPv4
 * 1: Unicast IPv6
 * Access: INDEX
 */
MLXSW_ITEM8(reg, ralcm, protocol, 0x2, 4, 4);

/* rmpe
 * ----
 *
 */
/* local_port
 * Local port number
 * CPU port is not supported
 * Access: INDEX
 */
MLXSW_ITEM8(reg, rmpe, local_port, 0x1, 0, 8);

/* rmpe_index
 * Router multicast port to ERIF
 * When 
 * ubridge
 * =0: Range is 0.. 
 * cap_max_rmpe
 *  - 
 * max_fid
 *  - 1
 * When 
 * ubridge
 * =1: Range is 0.. 
 * cap_max_rmpe
 *  - 1
 * Note: when 
 * ubridge
 * =1 the rmpe and smpe use the same range, see 
 * SMPE register
 * Access: INDEX
 */
MLXSW_ITEM16(reg, rmpe, rmpe_index, 0x6, 0, 16);

/* erif
 * Egress Router Interface
 * Valid range is 0..
 * cap_max_router_interfaces
 *  - 1
 * Access: RW
 */
MLXSW_ITEM16(reg, rmpe, erif, 0xa, 0, 16);

/* pecnee
 * ------
 *
 */
/* region_id
 * Region identifier
 * Range 0 .. 
 * cap_max_regions
 * -1
 * Note: the counter (PECNER) is always enabled. It is suggested 
 * to clear the counter (PECNER.
 * clear
 * ) after changing the 
 * region_id, erp_id_bitwise
 *  or 
 * ctcam
 * Access: RW
 */
MLXSW_ITEM16(reg, pecnee, region_id, 0xa, 0, 16);

/* region_id_mask
 * Region_id mask
 * Per bit:
 * 0: ignore 
 * region_id
 *  relevant bit
 * 1: compare 
 * region_id
 *  relevant bit
 * Can be used for a binary search on regions with high count val
 * ues
 * Range 0 .. 2^ (round_down(log2(
 * cap_max_regions
 * -1)) + 1)
 * Access: RW
 */
MLXSW_ITEM16(reg, pecnee, region_id_mask, 0xe, 0, 16);

/* erp_id_bitwise
 * Erp ID to count on
 * Value as bitwise. Can set either one erp or all erps. (e.g. value of 
 * b'101 is not allowed).
 * When more than 1 region is counted then all erps are counted
 * Reserved when 
 * region_id_mask
 *  != FF's (more than 1 region)
 * Access: RW
 */
MLXSW_ITEM16(reg, pecnee, erp_id_bitwise, 0x12, 0, 16);

/* ctcam
 * Count on C-TCAM
 * When more than 1 region then all C-TCAM access are counted
 * Reserved when 
 * region_id_mask
 *  != 0 (more than 1 region)
 * Access: RW
 */
MLXSW_ITEM8(reg, pecnee, ctcam, 0x17, 0, 1);

/* mdfcr
 * -----
 *
 */
/* device_type
 * Peripheral device type
 * 1: Vega Gearbox
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mdfcr, device_type, 0x3, 0, 8);

/* all
 * All devices are selected and 
 * device_index
 *  is ignored
 * When set to '1', the 
 * fw_status
 *  should represent the worst case of 
 * any of the devices. 
 * fw_version
 * , 
 * build_id
 * , 
 * major
 *  and 
 * minor
 *  should 
 * be of device number 0.
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mdfcr, all, 0x4, 7, 1);

/* device_index
 * Device number 
 * For gearboxes, the index represents the gearbox die.
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mdfcr, device_index, 0x6, 0, 12);

/* fw_status
 * FW load status.
 * 0: No errors, FW has loaded successfully. 
 * 1: Flash error. 
 * 2: FW load error. 
 * 15: Not ready yet for displaying the status.
 * Access: RO
 */
MLXSW_ITEM8(reg, mdfcr, fw_status, 0xd, 4, 4);

/* first_fw_status_device
 * The first device representing the 
 * fw_status
 * Access: RO
 */
MLXSW_ITEM16(reg, mdfcr, first_fw_status_device, 0xe, 0, 12);

/* expected_fw_version
 * Expected FW version
 * Access: RO
 */
MLXSW_ITEM32(reg, mdfcr, expected_fw_version, 0x10, 0, 32);

/* fw_version
 * FW version
 * Access: RO
 */
MLXSW_ITEM32(reg, mdfcr, fw_version, 0x14, 0, 32);

/* build_id
 * FW build ID
 * Access: RO
 */
MLXSW_ITEM16(reg, mdfcr, build_id, 0x1a, 0, 16);

/* major
 * FW major version
 * Access: RO
 */
MLXSW_ITEM8(reg, mdfcr, major, 0x1f, 0, 8);

/* minor
 * FW minor version
 * Access: RO
 */
MLXSW_ITEM8(reg, mdfcr, minor, 0x23, 0, 8);

/* error_id
 * FW burning status error.
 * 1: no errors
 * 2: error in total size
 * 3: error in iRAM size read
 * 4: error in DRAM size read
 * 5: SPI read from EEPROM time-out
 * 6: CRC on downloaded EEPROM content
 * 7: Download process is on-going
 * 8: SPI reset time-out
 * 9: memory protection
 * 10: unknown parameter was received by bootloader 
 * 11: invalid message was received by bootloader
 * 12: message was aborted by host
 * 13-32: Reserved
 * Access: RO
 */
MLXSW_ITEM8(reg, mdfcr, error_id, 0x26, 3, 5);

/* smpeb
 * -----
 *
 */
/* smpe_index
 * Switch multicast port to egress VID
 * When 
 * ubridge
 * =0: Range is 0.. 
 * cap_max_rmpe
 *  - 
 * max_fid
 *  - 1
 * When 
 * ubridge
 * =1: Range is 0.. 
 * cap_max_rmpe
 *  - 1
 * Note: when 
 * ubridge
 * =1 the rmpe and smpe use the same range, see 
 * RMPE register
 * Access: INDEX
 */
MLXSW_ITEM16(reg, smpeb, smpe_index, 0x6, 0, 16);

/* update
 * Update enable (when write):
 * 0: do not update the entry
 * 1: update the entry
 * Access: OP
 */
MLXSW_ITEM8_INDEXED(reg, smpeb, update, MLXSW_SMPEB_ELPORT_RECORD_BASE_LEN, 7, 1, MLXSW_SMPEB_ELPORT_RECORD_REC_LEN, 0, false);

/* value
 * Value:
 * egress vid, range 0..4095
 * Access: RW
 */
MLXSW_ITEM32_INDEXED(reg, smpeb, value, MLXSW_SMPEB_ELPORT_RECORD_BASE_LEN, 0, 20, MLXSW_SMPEB_ELPORT_RECORD_REC_LEN, 0, false);

/* pevpb
 * -----
 *
 */
/* local_port
 * Ingress local port 
 * Not including CPU port
 * Note: Spectrum-2: no VLAN binding for tunnel_port
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pevpb, local_port, 0x1, 0, 8);

/* ev
 * Enable VLAN binding from ingress port
 * 0: disable
 * 1: enable (default)
 * Access: RW
 */
MLXSW_ITEM8(reg, pevpb, ev, 0x7, 0, 1);

/* mtmp
 * ----
 *
 */
/* sensor_index
 * Sensors index to access.
 * 64-127 of 
 * sensor_index
 *  are mapped to the SFP+/QSFP modules 
 * sequentially (module 0 is mapped to 
 * sensor_index
 *  64, module 1 
 * to 
 * sensor_index
 *  65 and so on). Gearbox sensors are from index 
 * 256.
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mtmp, sensor_index, 0x2, 0, 12);

/* temperature
 * Temperature reading from the sensor. Reading is in 0.125 Cel
 * sius degrees units.
 * For negative values 2's complement is used (for example: -3.25 
 * Celsius will read as 0xFFE6)
 * Access: RO
 */
MLXSW_ITEM16(reg, mtmp, temperature, 0x6, 0, 16);

/* mte
 * Max Temperature Enable - enables measuring the max tempera
 * ture on a sensor
 * Access: RW
 */
MLXSW_ITEM8(reg, mtmp, mte, 0x8, 7, 1);

/* mtr
 * Max Temperature Reset - clears the value of the max tempera
 * ture register
 * Access: OP
 */
MLXSW_ITEM8(reg, mtmp, mtr, 0x8, 6, 1);

/* max_temperature
 * The highest measured temperature from the sensor.
 * When the bit 
 * mte
 *  is cleared, the field 
 * max_temperature
 *  is 
 * reserved.
 * Access: RO
 */
MLXSW_ITEM16(reg, mtmp, max_temperature, 0xa, 0, 16);

/* tee
 * Temperature Event Enable
 * 0 - do not generate event
 * 1 - generate event 
 * 2 - generate single event
 * Note: events may be delayed by up to 60 Seconds from "gener
 * ate event" or "generate single event"
 * Supported Only for switch devices. For HCA devices, SW 
 * should register Temperature Warning Event to an EQ.
 * Access: RW
 */
MLXSW_ITEM8(reg, mtmp, tee, 0xc, 6, 2);

/* temperature_threshold_hi
 * temperature_threshold_hi refers to the high threshold of Warn
 * ing Event. If the sensor temperature measurement is above the 
 * threshold (and events are enabled), an event will be generated.
 * threshold_hi
 *  and 
 * threshold_lo
 *  implements hysteresis mecha
 * nism of the threshold preventing toggling of the indication.
 * Note that 
 * temperature_threshold_hi
 *  must be equal or lower 
 * than the system requirement.
 * System requirement for module is the module warning tempera
 * ture.
 * System requirement for board/silicon sensors is according to 
 * product information parameters
 * Note that the temperature threshold can be used to generate an 
 * event message or an interrupt using GPIO
 * Access: RW
 */
MLXSW_ITEM16(reg, mtmp, temperature_threshold_hi, 0xe, 0, 16);

/* temperature_threshold_lo
 * temperature_threshold_hi refers to the low threshold of Warning 
 * Event. The offset 
 * threshold_lo 
 * implements the lower threshold 
 * for the hysteresis mechanism of over temperature alert. Once 
 * alert is set, if the temperature goes below this threshold, the alert 
 * is cleared.
 * Note that 
 * temperature_threshold_lo
 *  must be at least 5 degrees 
 * lower than 
 * temperature_threshold_hi
 * Access: RW
 */
MLXSW_ITEM16(reg, mtmp, temperature_threshold_lo, 0x12, 0, 16);

/* sensor_name_hi
 * Sensor Name
 * 8 character long sensor name
 * Access: RO
 */
MLXSW_ITEM32(reg, mtmp, sensor_name_hi, 0x18, 0, 32);

/* sensor_name_lo
 * Sensor Name
 * 8 character long sensor name
 * Access: RO
 */
MLXSW_ITEM32(reg, mtmp, sensor_name_lo, 0x1c, 0, 32);

/* ibfmr
 * -----
 *
 */
/* atm_v
 * Attribute Modifier valid
 * The 
 * attribute_modifier
 *  is valid
 * Access: RO
 */
MLXSW_ITEM8(reg, ibfmr, atm_v, 0x3, 0, 1);

/* attribute_id
 * Attribute ID of the received MAD
 * Supported:
 * 0x0019: LinearForwardingTable
 * 0x001B: MulticastForwardingTable
 * Access: RO
 */
MLXSW_ITEM16(reg, ibfmr, attribute_id, 0xa, 0, 16);

/* attribute_modifier
 * AttributeModifier of the received MAD
 * Access: RO
 */
MLXSW_ITEM32(reg, ibfmr, attribute_modifier, 0xc, 0, 32);

/* tncr_v2
 * -------
 *
 */
/* clear_counters
 * Clear counters
 * Access: OP
 */
MLXSW_ITEM8(reg, tncr_v2, clear_counters, 0x0, 7, 1);

/* tunnel_port
 * Tunnel port:
 * 0: NVE
 * Access: INDEX
 */
MLXSW_ITEM8(reg, tncr_v2, tunnel_port, 0x3, 0, 4);

/* count_decap_discards_high
 * Count number of packets had decapsulation discards of NVE 
 * tunneling
 * Access: RO
 */
MLXSW_ITEM32(reg, tncr_v2, count_decap_discards_high, 0x28, 0, 32);

/* count_decap_discards_low
 * Count number of packets had decapsulation discards of NVE 
 * tunneling
 * Access: RO
 */
MLXSW_ITEM32(reg, tncr_v2, count_decap_discards_low, 0x2c, 0, 32);

/* count_encap_discards_high
 * Count number of packets had encapsulation discards of NVE 
 * tunneling
 * Access: RO
 */
MLXSW_ITEM32(reg, tncr_v2, count_encap_discards_high, 0x30, 0, 32);

/* count_encap_discards_low
 * Count number of packets had encapsulation discards of NVE 
 * tunneling
 * Access: RO
 */
MLXSW_ITEM32(reg, tncr_v2, count_encap_discards_low, 0x34, 0, 32);

/* ppbs
 * ----
 *
 */
/* swid
 * Switch partition ID for queries. Reserved on Write.
 * Reserved when Spectrum/-2
 * Access: INDEX
 */
MLXSW_ITEM8(reg, ppbs, swid, 0x4, 0, 8);

/* type
 * Entry type:
 * 0x0: Unicast_Record
 * 0x1: Unicast_LAG_Record
 * 0x2: Multicast_Record
 * 0xC: Unicast_Tunnel_Record
 * 0xF: Multicast_Tunnel_Record
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, type, 0x5, 4, 4);

/* pbs_ptr
 * Index into the PBS table. 
 * In SwitchX/-2 
 * pbs_ptr
 *  is limited to 0 .. (
 * pbs_table_size
 * -1)
 * For 
 * Spectrum/-2
 * , the index points to the KVD Linear, see 
 * Appendix 
 * A.3.1.2, "KVD Central Database Linear Entries" (page 2169)
 * Access: INDEX
 */
MLXSW_ITEM32(reg, ppbs, pbs_ptr, 0x8, 0, 24);

/* ppbs_unicast_v_fid
 * valid FID:
 * 0: .1Q bridge, the VID is maintained
 * 1: .1D bridge, the VID is modified according to:
 * {fid, system_port} -> vid
 * Where the mapping is according to SVFA register
 * Reserved when 
 * ubridge
 * =1
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, ppbs_unicast_v_fid, 0xc, 7, 1);

/* ppbs_unicast_set_vid
 * Set VID:
 * 0: do not update VID
 * 1: set VID
 * For Spectrum-2 if 
 * smpe_valid
 * =1 then the smpe will overwrite this 
 * configured vid
 * Reserved when 
 * ubridge
 * =0
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, ppbs_unicast_set_vid, 0xc, 6, 1);

/* ppbs_unicast_vid
 * New VID when 
 * set_vid
 *  = 1
 * Reserved when 
 * set_vid
 *  = 0
 * Reserved when 
 * ubridge
 * =0
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_unicast_vid, 0xc, 0, 12);

/* ppbs_unicast_fid
 * Filtering identifier (FID)
 * Reserved when 
 * v_fid
 *  = 0
 * Reserved when 
 * ubridge
 * =1
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_unicast_fid, 0xe, 0, 16);

/* ppbs_unicast_action
 * Action to apply on the packet:
 * 0: NOP - forward (based on the system_port destination)
 * 3: FORWARD_TO_IP_ROUTER
 * 4: FORWARD_TO_FCF - 
 * Reserved when Spectrum/-2
 * 5: DISCARD - 
 * Reserved when Spectrum/-2
 * 15: DISCARD_ERROR
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, ppbs_unicast_action, 0x10, 4, 4);

/* ppbs_unicast_system_port
 * Unique port identifier for the final destination of the packet
 * Must be '0' when 
 * action
 *  is '3' - forward to IP router 
 * For SwitchX/-2 value of 0 is for drop
 * Note: for 
 * Spectrum/-2
 * , if 
 * action
 *  is 0 (forward) and 
 * system_port
 *  is 0 
 * then the PPBS entry must not be used! (Must not be pointed by an 
 * ACL action)
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_unicast_system_port, 0x12, 0, 16);

/* unicast_lag_uvid
 * Update VID. 
 * If set, the packet's VLAN ID is updated to 
 * vid
 * . This can be used for 
 * .1D entries.
 * Reserved when SwitchX/-2
 * For Spectrum-2 if 
 * smpe_valid
 * =1 then the smpe will overwrite this 
 * configured vid
 * Note: supported regardless of 
 * ubridge
 *  value
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, unicast_lag_uvid, 0xe, 7, 1);

/* unicast_lag_vid
 * VLAN ID to be used when 
 * uvid 
 * is set. 
 * Reserved when 
 * uvid
 *  = 0
 * Note: supported regardless of 
 * ubridge
 *  value
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, unicast_lag_vid, 0xe, 0, 12);

/* unicast_lag_lag_id
 * LAG Identifier - pointer into the LAG descriptor table, see also 
 * Section 6.2.9, "
 * LAG Descriptor Table
 * ," on page 755
 * .
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, unicast_lag_lag_id, 0x12, 0, 10);

/* ppbs_multicast_v_fid
 * valid FID:
 * 0: .1Q bridge
 * 1: .1D bridge
 * Reserved when 
 * ubridge
 * =1
 * Reserved when Spectrum-2
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, ppbs_multicast_v_fid, 0xc, 7, 1);

/* ppbs_multicast_pgi
 * Multicast port group index - index into the Port Group Table.
 * Value 0x1FFF indicates the 
 * pgi
 *  should point to the MID entry.
 * For 
 * Spectrum/-2
 *  this value must be set to 0x1FFF
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_multicast_pgi, 0xc, 0, 13);

/* ppbs_multicast_fid
 * Filtering identifier (FID)
 * Reserved when 
 * v_fid
 *  = 0
 * Reserved when 
 * ubridge
 * =1
 * Reserved when Spectrum-2
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_multicast_fid, 0xe, 0, 16);

/* ppbs_multicast_mid
 * Multicast port group index - index to the port group table.
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, ppbs_multicast_mid, 0x12, 0, 16);

/* unicast_tunnel_udip
 * If 
 * protocol
 *  is IPv4:
 * The underlay destination IPv4 of the remote VTEP
 * If 
 * protocol
 *  is IPv6:
 * A pointer to the IPv6 address of the remote VTEP destination in 
 * the overlay network. See 
 * Section 13.10.19, "
 * RIPS - Router IP ver
 * sion Six Register
 * ," on page 1898
 * Access: RW
 */
MLXSW_ITEM32(reg, ppbs, unicast_tunnel_udip, 0xc, 0, 32);

/* unicast_tunnel_protocol
 * Protocol:
 * 0: IPv4
 * 1: IPv6
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, unicast_tunnel_protocol, 0x10, 3, 1);

/* multicast_tunnel_underlay_mc_ptr_msb
 * Most significant bits of Underlay Multicast Pointer. Used as a 
 * pointer to the first entry of the group based link lists of MC entries 
 * (for NVE tunnels). The number of link lists in the group is config
 * ured by TNGCR.
 * nve_hash_size_mc
 * , see 
 * Section 15.11.1, 
 * "
 * TNGCR - Tunneling NVE General Configuration Register
 * ," on 
 * page 2046
 * The pointer points to entries which are configured by TNUMT, see 
 * Section 15.11.5, "
 * TNUMT - Tunneling NVE Underlay Multicast 
 * Table Register
 * ," on page 2055
 * .
 * For Spectrum/-2, this points to an entry in the KVD Linear, see 
 * Appendix A.4.1, "
 * KVD Central Database
 * " (page 2174)
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, multicast_tunnel_underlay_mc_ptr_msb, 0xc, 0, 16);

/* multicast_tunnel_fid
 * Filtering identifier (FID)
 * Reserved when 
 * v_fid
 *  = 0
 * Reserved when 
 * ubridge
 * =1
 * Reserved when Spectrum-2
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, multicast_tunnel_fid, 0xe, 0, 16);

/* multicast_tunnel_underlay_mc_ptr_lsb
 * Least significant bits of pointer to link list of flooding entries (for 
 * NVE tunnels)
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, multicast_tunnel_underlay_mc_ptr_lsb, 0x10, 0, 8);

/* multicast_tunnel_v_fid
 * valid FID:
 * 0: .1Q bridge
 * 1: .1D bridge
 * Reserved when 
 * ubridge
 * =1
 * Reserved when Spectrum-2
 * Access: RW
 */
MLXSW_ITEM8(reg, ppbs, multicast_tunnel_v_fid, 0x11, 7, 1);

/* multicast_tunnel_mid
 * Multicast identifier - global identifier that represents the multicast 
 * group across all devices
 * Access: RW
 */
MLXSW_ITEM16(reg, ppbs, multicast_tunnel_mid, 0x12, 0, 16);

/* rtdp
 * ----
 *
 */
/* type
 * Type of the RTDP entry:
 * 0: NVE
 * 1: IPinIP
 * Access: RW
 */
MLXSW_ITEM8(reg, rtdp, type, 0x0, 4, 4);

/* tunnel_index
 * Index to the Decap entry
 * For Spectrum, Index to KVD Linear, see 
 * Section A.3.1.2, "
 * KVD 
 * Central Database Linear Entries
 * ," on page 2169
 * Access: INDEX
 */
MLXSW_ITEM32(reg, rtdp, tunnel_index, 0x0, 0, 24);

/* rtdp_ipinip_irif
 * Ingress Router Interface for the overlay router
 * Access: RW
 */
MLXSW_ITEM16(reg, rtdp, rtdp_ipinip_irif, 0x4, 0, 16);

/* rtdp_ipinip_sip_check
 * 0: No sip checks 
 * 1: filter packet if underlay is not IPv4 or if underlay SIP does 
 * not equal to 
 * ipv4_usip
 * 3: filter packet if underlay is not IPv6 
 * or if underlay SIP does not equal to 
 * ipv6_usip
 * If decapsulation failed due to these configurations then 
 * trap_id is IPIP_DECAP_ERROR
 * Access: RW
 */
MLXSW_ITEM8(reg, rtdp, rtdp_ipinip_sip_check, 0x7, 0, 3);

/* rtdp_ipinip_type_check
 * Bit0:
 * 0: do not allow IPinIP (without GRE) decapsulation
 * 1: allow IPinIP (without GRE) decapsulation
 * Bit1:
 * 0: do not allow IPinGREinIP without a key decapsulation
 * 1: allow IPinGREinIP without a key decapsulation
 * Bit2:
 * 0: do not allow IPinGREinIP with a key decapsulation
 * 1: allow IPinGREinIP with a key decapsulation
 * If decapsulation failed due to these configurations then 
 * trap_id is IPIP_DECAP_ERROR
 * Access: RW
 */
MLXSW_ITEM8(reg, rtdp, rtdp_ipinip_type_check, 0x8, 0, 3);

/* rtdp_ipinip_gre_key_check
 * 0: do not check GRE key
 * 1: Check GRE key
 * When check is enabled:
 * A packet received as IPinIP (without GRE) will always pass.
 * A packet received as IPinGREinIP without a key will not 
 * pass the check.
 * A packet received as IPinGREinIP with a key will pass the 
 * check only if the key in the packet is equal to 
 * expect
 * ed_gre_key
 * .
 * If decapsulation failed due to GRE key then trap_id is IPIP_
 * DECAP_ERROR
 * Access: RW
 */
MLXSW_ITEM8(reg, rtdp, rtdp_ipinip_gre_key_check, 0x9, 7, 1);

/* rtdp_ipinip_ipv4_usip
 * Underlay IPv4 address for ipv4 
 * source address 
 * check
 * Reserved when 
 * sip_check
 *  is not '1'
 * Access: RW
 */
MLXSW_ITEM32(reg, rtdp, rtdp_ipinip_ipv4_usip, 0xc, 0, 32);

/* rtdp_ipinip_ipv6_usip_ptr
 * This field is valid when 
 * sip_check
 *  is "sipv6 check explic
 * itly"
 * This is a pointer to the IPv6 DIP which is configured by 
 * RIPS, see 
 * Section 13.10.19, "
 * RIPS - Router IP version Six 
 * Register
 * ," on page 1898
 * For Spectrum, the index is to the KVD linear, see 
 * Section A.3.1, "
 * KVD Central Database
 * ," on page 2166
 * Reserved when 
 * sip_check
 *  is not '2' or '3'
 * Access: RW
 */
MLXSW_ITEM32(reg, rtdp, rtdp_ipinip_ipv6_usip_ptr, 0x10, 0, 24);

/* rtdp_ipinip_expected_gre_key
 * GRE key for checking
 * Reserved when 
 * gre_key_check
 *  is '0'
 * Access: RW
 */
MLXSW_ITEM32(reg, rtdp, rtdp_ipinip_expected_gre_key, 0x14, 0, 32);

/* egress_router_interface
 * Underlay egress router interface
 * Range is 0 .. 
 * cap_max_router_interfaces
 *  - 1
 * Reserved when Spectrum-1
 * Access: RW
 */
MLXSW_ITEM16(reg, rtdp, egress_router_interface, 0x42, 0, 16);

/* pecner
 * ------
 *
 */
/* clear
 * Clear counters
 * Access: OP
 */
MLXSW_ITEM8(reg, pecner, clear, 0x0, 7, 1);

/* erp_initial_high
 * ERP or C-TCAM is initial active after erpt_vector (phase 1)
 * Note: if n (erps + ctcam) are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_initial_high, 0x10, 0, 32);

/* erp_initial_low
 * ERP or C-TCAM is initial active after erpt_vector (phase 1)
 * Note: if n (erps + ctcam) are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_initial_low, 0x14, 0, 32);

/* erp_post_bf_high
 * ERP active after bloom filter (phase 2)
 * Doesn't increment as C-TCAM
 * Note: if n erps are enabled then the counter may increase by 0..n 
 * for a given region lookup
 * Note: when PERCR.
 * bf_bypass
 * =1 then this counter does not 
 * count.
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_post_bf_high, 0x18, 0, 32);

/* erp_post_bf_low
 * ERP active after bloom filter (phase 2)
 * Doesn't increment as C-TCAM
 * Note: if n erps are enabled then the counter may increase by 0..n 
 * for a given region lookup
 * Note: when PERCR.
 * bf_bypass
 * =1 then this counter does not 
 * count.
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_post_bf_low, 0x1c, 0, 32);

/* erp_lookup_high
 * ERP or CTCAM had a lookup - active after bloom filter and 
 * pruning (phase 3)
 * Note: if n erps + ctcam are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_lookup_high, 0x20, 0, 32);

/* erp_lookup_low
 * ERP or CTCAM had a lookup - active after bloom filter and 
 * pruning (phase 3)
 * Note: if n erps + ctcam are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_lookup_low, 0x24, 0, 32);

/* erp_any_match_high
 * ERP or CTCAM had a match (not yet a final match - later prior
 * ity will choose the final)
 * Note: if n erps + ctcam are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_any_match_high, 0x28, 0, 32);

/* erp_any_match_low
 * ERP or CTCAM had a match (not yet a final match - later prior
 * ity will choose the final)
 * Note: if n erps + ctcam are enabled then the counter may 
 * increase by 0..n for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_any_match_low, 0x2c, 0, 32);

/* erp_final_match_high
 * ERP or CTCAM had a final match
 * Note: the counter may increase by 0..1 for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_final_match_high, 0x30, 0, 32);

/* erp_final_match_low
 * ERP or CTCAM had a final match
 * Note: the counter may increase by 0..1 for a given region lookup
 * Access: RO
 */
MLXSW_ITEM32(reg, pecner, erp_final_match_low, 0x34, 0, 32);

/* iicr
 * ----
 *
 */
/* kvh_mark_clear
 * KVH mark and clear
 * 0: Nop 
 * 1: Mark all KVH entries (e.g. before ISFU)
 * 2: Clear (delete) all marked KVH entries (e.g. after ISFU)
 * Spectrum-1: mark/delete only KVH hash entries
 * Spectrum-2: mark/delete KVH hash and KVH linear entries
 * Note: dump sessions must not be ongoing between mark and 
 * clear. e.g. SFN, SFDD
 * , RAUHTD, PEFAAD, MPNHLFED, 
 * TNIPSN
 * Access: OP
 */
MLXSW_ITEM8(reg, iicr, kvh_mark_clear, 0xb, 0, 4);

/* clear_pe_regions_value
 * clear (deallocate) policy engine TCAM regions if: 
 * (1) region[bit] = 
 * clear_pe_regions_value
 * [bit] 
 * (2) and 
 * clear_pe_regions_mask
 * [bit]=1
 * Note: a used TCAM region must not be cleared (if traffic is pass
 * ing through this region). An ACL may point to this unused 
 * TCAM region.
 * If mask=0 then this is a Nop
 * Access: OP
 */
MLXSW_ITEM16(reg, iicr, clear_pe_regions_value, 0x12, 0, 16);

/* clear_pe_regions_mask
 * clear (deallocate) policy engine TCAM regions if: 
 * (1) region[bit] = 
 * clear_pe_regions_value
 * [bit] 
 * (2) and 
 * clear_pe_regions_mask
 * [bit]=1
 * Note: a used TCAM region must not be cleared (if traffic is pass
 * ing through this region). An ACL may point to this unused 
 * TCAM region.
 * If mask=0 then this is a Nop
 * Access: OP
 */
MLXSW_ITEM16(reg, iicr, clear_pe_regions_mask, 0x16, 0, 16);

/* clear_rifs_value
 * clear (deallocate) router interface (RIF) if: 
 * (1) rif[bit] = 
 * clear_rifs_value
 * [bit] 
 * (2) and 
 * clear_rifs_mask
 * [bit]=1
 * Note: a used RIF must not be cleared (if traffic is passing 
 * through this RIF).
 * If mask=0 then this is a Nop
 * Access: OP
 */
MLXSW_ITEM16(reg, iicr, clear_rifs_value, 0x1a, 0, 16);

/* clear_rifs_mask
 * clear (deallocate) router interface (RIF) if: 
 * (1) rif[bit] = 
 * clear_rifs_value
 * [bit] 
 * (2) and 
 * clear_rifs_mask
 * [bit]=1
 * Note: a used RIF must not be cleared (if traffic is passing 
 * through this RIF).
 * If mask=0 then this is a Nop
 * Access: OP
 */
MLXSW_ITEM16(reg, iicr, clear_rifs_mask, 0x1e, 0, 16);

/* traps_2_default
 * Set all trap_id's actions to default as after reset.
 * Access: OP
 */
MLXSW_ITEM8(reg, iicr, traps_2_default, 0x23, 0, 1);

/* peapbm
 * ------
 *
 */
/* region_id
 * Region identifier
 * Range 0 .. 
 * cap_max_regions
 * -1
 * Note: the register updates all duplicated regions
 * Access: INDEX
 */
MLXSW_ITEM16(reg, peapbm, region_id, 0x2, 0, 16);

/* c_s
 * Clear or set:
 * 0: prune clear
 * 1: prune set
 * Access: WO
 */
MLXSW_ITEM8(reg, peapbm, c_s, 0x10, 7, 1);

/* pruning_ctcam_cs
 * Pruning C-TCAM clear or set. Clear or set defined by 
 * c_s
 * 0: don't modify prune_ctcam bit
 * 1: modify the prune_ctcam bit
 * Access: WO
 */
MLXSW_ITEM8(reg, peapbm, pruning_ctcam_cs, 0x10, 4, 1);

/* erp_id_mask
 * erp id mask, per bit:
 * 0: for both values of 
 * erp_id
 *  bit
 * 1: for value according to 
 * erp_id
 *  bit
 * Example: mask 1111 - update only 
 * erp_id
 * , mask 0000 - update all 
 * erps
 * Access: INDEX
 */
MLXSW_ITEM8(reg, peapbm, erp_id_mask, 0x12, 0, 4);

/* erp_id
 * erp id
 * Access: INDEX
 */
MLXSW_ITEM8(reg, peapbm, erp_id, 0x13, 0, 4);

/* pruning_vector_cs
 * Pruning vector clear or set. Modify option defined by 
 * c_s
 * Per bit:
 * 0: don't modify pruning_vector bit
 * 1: modify the pruning_vector bit
 * Access: WO
 */
MLXSW_ITEM16(reg, peapbm, pruning_vector_cs, 0x16, 0, 16);

/* priority_start
 * Update will be from 
 * priority_start
 *  (inclusive) to 
 * priority_end
 *  
 * (inclusive).
 * For Spectrum-2 range is 1.. 
 * cap_kvd_size
 * -1
 * Access: INDEX
 */
MLXSW_ITEM32(reg, peapbm, priority_start, 0x18, 0, 24);

/* priority_end
 * Update will be from 
 * priority_start
 *  (inclusive) to 
 * priority_end
 *  
 * (inclusive).
 * For Spectrum-2 range is 1.. 
 * cap_kvd_size
 * -1
 * Access: INDEX
 */
MLXSW_ITEM32(reg, peapbm, priority_end, 0x1c, 0, 24);

/* key
 * ACL Key as described in 
 * Section 10.6.2, "
 * Flex2 ACL Key Blocks 
 * Layout
 * ," on page 1420
 * Note: for regions which have 12 Key Blocks the 6 lsb Key Blocks 
 * are valid and the 6 msb Key Blocks are not used for this function
 * Access: INDEX
 */
MLXSW_ITEM32_INDEXED(reg, peapbm, key, 0x20, 0, 32, 4, 0, false);

/* key_mask
 * Mask
 * Mask entries which match the key with this mask. Per bit:
 * 0: ignore bit 
 * key
 *  (always match)
 * 1: compare bit in 
 * key
 * Note: for regions which have 12 Key Blocks the 6 lsb Key Blocks 
 * are valid and the 6 msb Key Blocks are not used for this function
 * Access: INDEX
 */
MLXSW_ITEM32_INDEXED(reg, peapbm, key_mask, 0x80, 0, 32, 4, 0, false);

/* large_entry_key_id
 * Large entry key ID
 * A key for 12 Key block rules
 * Reserved when the region has 2, 4 or 6 key blocks
 * Range 0 .. 
 * cap_max_pe_large_key_id
 * - 1
 * Access: INDEX
 */
MLXSW_ITEM32(reg, peapbm, large_entry_key_id, 0xe0, 0, 24);

/* large_entry_key_id_mask
 * Large entry key ID mask
 * 0: ignore bit 
 * large_entry_key_id
 *  (always match)
 * 1: compare bit in 
 * large_entry_key_id
 * Reserved when the region has 2, 4 or 6 key blocks
 * Range 0 .. 
 * cap_max_pe_large_key_id
 * - 1
 * Access: INDEX
 */
MLXSW_ITEM32(reg, peapbm, large_entry_key_id_mask, 0xe4, 0, 24);

/* delta_start
 * Start point of delta value and mask
 * Units of bits
 * Reserved when 
 * delta_mask
 *  = 0
 * Access: INDEX
 */
MLXSW_ITEM16(reg, peapbm, delta_start, 0xf2, 0, 10);

/* delta_mask
 * Delta mask
 * Per bit:
 * 0: ignore relevant bit from offset 
 * delta_start
 * 1: compare relevant bit from offset 
 * delta_start
 * Access: INDEX
 */
MLXSW_ITEM8(reg, peapbm, delta_mask, 0xf5, 0, 8);

/* delta_value
 * Delta value
 * Relevant only for large keys when delta_start >= 27*8bits
 * For all other cases the delta_value is given in the 
 * key
 * Access: INDEX
 */
MLXSW_ITEM8(reg, peapbm, delta_value, 0xf7, 0, 8);

/* ibfmrc
 * ------
 *
 */
/* attr_id_en
 * Attribute ID enable:
 * bit0: 0x0019: LinearForwardingTable
 * bit1: 0x001B: MulticastForwardingTable
 * Access: RW
 */
MLXSW_ITEM32(reg, ibfmrc, attr_id_en, 0x0, 0, 32);

/* peaps
 * -----
 *
 */
/* busy
 * Busy:
 * 0: READY - can accept a new priority shift command
 * 1: BUSY - cannot accept a new priority shift command
 * Regardless of region
 * Access: RO
 */
MLXSW_ITEM8(reg, peaps, busy, 0x0, 7, 1);

/* ovf
 * Overflow:
 * 0: previous session ended okay
 * 1: previous session had an overflow 
 * Overflow example: value of 90 was shifted by -100 to -10
 * This field is cleared at every read or write access
 * Regardless of region
 * Access: RO
 */
MLXSW_ITEM8(reg, peaps, ovf, 0x0, 6, 1);

/* ct_offset
 * Offset within the C-TCAM region to start the priority shift
 * Reserved when 
 * ct_size
 *  = 0
 * Access: WO
 */
MLXSW_ITEM16(reg, peaps, ct_offset, 0xa, 0, 16);

/* ct_size
 * The number of rules in the C-TCAM to do the priority shift, starting 
 * from 
 * ct_offset
 * Access: WO
 */
MLXSW_ITEM16(reg, peaps, ct_size, 0xe, 0, 16);

/* tcam_region_info
 * Opaque object that represents the TCAM region
 * See 
 * Section 10.10.10, "
 * PTAR - Policy-Engine TCAM Allocation 
 * Register
 * ," on page 1600
 * .
 * This is the base region. All duplicated region_id's will be shifted as 
 * well. See 
 * Section 10.10.14, "
 * PERD - Policy-Engine Region Dupli
 * cation Register
 * ," on page 1609
 * See 
 * Section 1639, "
 * tcam_re
 * gion_info Layout
 * ," on page 1653
 * Access: WO
 */
MLXSW_ITEM_BUF(reg, peaps, tcam_region_info, 0x10, 16);

/* priority_start
 * Initial start priority
 * For Spectrum-2 range is 1.. 
 * cap_kvd_size
 * -1
 * Access: WO
 */
MLXSW_ITEM32(reg, peaps, priority_start, 0x20, 0, 24);

/* priority_end
 * Initial end priority
 * Must be equal or greater than 
 * priority_start
 * For Spectrum-2 range is 1.. 
 * cap_kvd_size
 * -1
 * Access: WO
 */
MLXSW_ITEM32(reg, peaps, priority_end, 0x24, 0, 24);

/* priority_inc
 * 2's complement value for priority increase or decrease
 * Access: WO
 */
MLXSW_ITEM32(reg, peaps, priority_inc, 0x30, 0, 24);

/* iddd
 * ----
 *
 */
/* entry_type
 * Entry type
 * For Spectrum-2 hash entries see 
 * Appendix A.4.1.1, "
 * KVD Central 
 * Database Hash-based
 * " (page 2175)
 * For Spectrum-2 linear entries see 
 * Appendix A.4.1.2, "
 * KVD Cen
 * tral Database Linear Entries
 * " (page 2176)
 * Access: INDEX
 */
MLXSW_ITEM8(reg, iddd, entry_type, 0x3, 0, 8);

/* duplication
 * Duplication
 * Valid values:
 * 1, 2, 4, 8, 16
 * Default is 1
 * Access: RW
 */
MLXSW_ITEM8(reg, iddd, duplication, 0x7, 0, 5);

/* iedr
 * ----
 *
 */
/* bg
 * Background delete:
 * 0: immediate delete operation (a.k.a. sync)
 * 1: background delete operation (a.k.a. async). SW must poll for 
 * IEDS.
 * ed_status
 * =0 before attempting new deletes
 * Access: OP
 */
MLXSW_ITEM8(reg, iedr, bg, 0x0, 0, 1);

/* num_rec
 * Number of records
 * Range 1..64
 * When 
 * bg
 * =1 the 
 * num_rec
 *  =1 and this field is reserved
 * Access: OP
 */
MLXSW_ITEM8(reg, iedr, num_rec, 0x3, 0, 8);

/* type
 * Resource type
 * For Spectrum-2, see 
 * Section A.4.1.2, "
 * KVD Central Database Lin
 * ear Entries
 * ," on page 2176
 * Access: OP
 */
MLXSW_ITEM8_INDEXED(reg, iedr, type, MLXSW_IEDR_RECORD_BASE_LEN, 0, 8, MLXSW_IEDR_RECORD_REC_LEN, 0, false);

/* size
 * Size of entries do be deleted
 * The unit is 1 entry, regardless of entry type
 * Access: OP
 */
MLXSW_ITEM16_INDEXED(reg, iedr, size, MLXSW_IEDR_RECORD_BASE_LEN + 2, 0, 11, MLXSW_IEDR_RECORD_REC_LEN, 0, false);

/* index_start
 * Resource index start
 * Access: OP
 */
MLXSW_ITEM32_INDEXED(reg, iedr, index_start, MLXSW_IEDR_RECORD_BASE_LEN, 0, 24, MLXSW_IEDR_RECORD_REC_LEN, 4, false);

/* ieds
 * ----
 *
 */
/* edpr
 * Entry Delete Priority
 * When set FW will give higher priority for the current ongoing 
 * entry delete process. Can be set also while entry delete process is 
 * ongoing. Affects only current process. By default all process 
 * start as low prio
 * Access: OP
 */
MLXSW_ITEM8(reg, ieds, edpr, 0x3, 0, 1);

/* ed_status
 * Entry delete status:
 * 0: No entry delete process is ongoing
 * 1: Entry delete process is ongoing
 * Access: RO
 */
MLXSW_ITEM8(reg, ieds, ed_status, 0x7, 0, 4);

/* mafti
 * -----
 *
 */
/* bank_id
 * Bank ID
 * Access: RO
 */
MLXSW_ITEM8(reg, mafti, bank_id, 0x1, 0, 3);

/* num_rec
 * Number of records
 * Range 1..64
 * Access: RO
 */
MLXSW_ITEM8(reg, mafti, num_rec, 0x3, 0, 8);

/* counter_index
 * Counter Index for flow counters.
 * For Spectrum-2 see 
 * Section 4.2, "
 * Flow Counters
 * ," on page 588
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, mafti, counter_index, MLXSW_MAFTI_RECORD_BASE_LEN, 0, 24, MLXSW_MAFTI_RECORD_REC_LEN, 0, false);

/* bytes_inc
 * Bytes to increment to bytes counter
 * Unit of 512B
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, mafti, bytes_inc, MLXSW_MAFTI_RECORD_BASE_LEN, 0, 32, MLXSW_MAFTI_RECORD_REC_LEN, 4, false);

/* packets_inc
 * Packets to increment to packets counter
 * Unit is 4 packets
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, mafti, packets_inc, MLXSW_MAFTI_RECORD_BASE_LEN, 0, 32, MLXSW_MAFTI_RECORD_REC_LEN, 8, false);

/* tnqcr
 * -----
 *
 */
/* enc_set_dscp
 * For encapsulation: how to set DSCP field:
 * 0: Copy the DSCP from the overlay (inner) IP header to the 
 * underlay (outer) IP header. If there is no IP header, use 
 * TNQDR.
 * dscp
 * 1: Set the DSCP field as the TNQDR.
 * dscp
 * The 
 * dscp
 *  field is configured in TNQDR register. See 
 * Section 15.11.7, "
 * TNQDR - Tunneling NVE QoS Default Regis
 * ter
 * ," on page 2060
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, enc_set_dscp, 0x4, 4, 1);

/* enc_set_sp
 * For encapsulation: how to set Switch Priority and packet Color:
 * 0: Preserve Switch Priority and packet Color
 * 1: Set new Switch Priority and packet Color as configured by 
 * TNQDR.
 * See 
 * Section 15.11.7, "
 * TNQDR - Tunneling NVE QoS Default 
 * Register
 * ," on page 2060
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, enc_set_sp, 0x4, 0, 1);

/* enc_dscp_rw
 * For encapsulation: how to handle the 
 * dscp_rewrite_en
 * :
 * 0: Preserve the value of the 
 * dscp_rewrite_en
 * 2: Clear the 
 * dscp_rewrite_en
 * 3: Set the 
 * dscp_rewrite_en
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, enc_dscp_rw, 0x7, 2, 2);

/* enc_pcp_rw
 * For encapsulation: how to handle the 
 * pcp_rewrite_en
 * :
 * 0: Preserve the value of the 
 * pcp_rewrite_en
 * 2: Clear the 
 * pcp_rewrite_en
 * 3: Set the 
 * pcp_rewrite_en
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, enc_pcp_rw, 0x7, 0, 2);

/* dec_set_dscp
 * For decapsulation: how to set the overlay DSCP field, if exists, 
 * while stripping off the underlay headers:
 * 0: Preserve inner DSCP
 * 1: Copy the DSCP from the underlay IP header
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, dec_set_dscp, 0x8, 4, 1);

/* dec_set_sp
 * For decapsulation: how to set Switch Priority and packet Color:
 * 0: Preserve Switch Priority
 * 1: Set a new Switch Priority from overlay DSCP as configured 
 * by RDPM (of the overlay packet, even if not routed).
 * See 
 * Section 13.10.20, "
 * RDPM - Router DSCP to Priority Map
 * ping Register
 * ," on page 1899
 * .
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, dec_set_sp, 0x8, 0, 1);

/* dec_set_pcp
 * For decapsulation: how to set the overlay PCP,DEI fields:
 * 0: Preserve/Set inner PCP,DEI when push. When untagged push 
 * value of 0 for PCP,DEI 
 * 1: Copy the PCP,DEI from the underlay L2 header (default)
 * Note: Spc-1 supports only '1' Copy
 * Reserved when Spectrum-1
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, dec_set_pcp, 0x9, 4, 1);

/* dec_dscp_rw
 * For decapsulation: how to handle the 
 * dscp_rewrite_en
 * :
 * 0: Preserve the value of the 
 * dscp_rewrite_en
 * 2: Clear the 
 * dscp_rewrite_en
 * 3: Set the 
 * dscp_rewrite_en
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, dec_dscp_rw, 0xb, 2, 2);

/* dec_pcp_rw
 * For decapsulation: how to handle the 
 * pcp_rewrite_en
 * :
 * 0: Preserve the value of the 
 * pcp_rewrite_en
 * 2: Clear the 
 * pcp_rewrite_en
 * 3: Set the 
 * pcp_rewrite_en
 * Access: RW
 */
MLXSW_ITEM8(reg, tnqcr, dec_pcp_rw, 0xb, 0, 2);

/* mpagr
 * -----
 *
 */
/* swid
 * Switch Partition ID
 * Reserved when 
 * mngr_type
 *  = LNM
 * Reserved when Ethernet switches
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mpagr, swid, 0x0, 0, 8);

/* mngr_type
 * Manager Type
 * 0: HYPERVISOR - config all ports
 * 1: LNM - local network manager - config all ports of the SWID
 * Reserved when Ethernet switches
 * Access: OP
 */
MLXSW_ITEM8(reg, mpagr, mngr_type, 0x2, 0, 4);

/* trigger
 * Mirror trigger 
 * See 
 * Table 486, "
 * Mirror triggers
 * ," on page 595
 * Reserved when the mirror binding is not Global
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mpagr, trigger, 0x3, 0, 4);

/* enable
 * Enable mirroring 
 * By default, port mirroring is disabled for all ports.
 * Reserved when Quantum 
 * and Spectrum-2
 * .
 * Access: RW
 */
MLXSW_ITEM8(reg, mpagr, enable, 0x4, 7, 1);

/* pa_id
 * Port analyzer ID
 * Access: RW
 */
MLXSW_ITEM8(reg, mpagr, pa_id, 0x7, 0, 4);

/* probability_rate
 * Sampling rate = 1 out of 
 * rate
 *  packets 
 * Valid values are: 1 to 3.5*10^9
 * Value of 1 means "sample all"
 * Default 1
 * Note: high values are round by HW to: 10^9 * {4.3, 2.15, 1.43, 
 * 1.08, 0.86, 0.72, 0.61, 0.54}.
 * Access: RW
 */
MLXSW_ITEM32(reg, mpagr, probability_rate, 0x8, 0, 32);

/* sbhrr_v2
 * --------
 *
 */
/* clr
 * Clear:
 * 0: Read the data in the histogram agent
 * 1: Read and clear the data in the histogram agent
 * Access: OP
 */
MLXSW_ITEM8(reg, sbhrr_v2, clr, 0x0, 7, 1);

/* local_port
 * Local port number.
 * For Ingress: excludes CPU port
 * For Egress: includes CPU port
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhrr_v2, local_port, 0x1, 0, 8);

/* pg_buff
 * PG buffer - Port PG (
 * dir
 * =ingress) / traffic class (
 * dir
 * =egress)
 * For PG buffer: range is 0..
 * cap_max_pg_buffers
 *  - 1
 * For traffic class: range is 0..
 * cap_max_tclass
 *  - 1
 * For traffic class to CPU port: range is 0..
 * cap_max_cpu_ingress_t
 * class
 * - 1
 * see 
 * Section 11.5, "Ethernet Switch Packet Priority and 
 * TClass Mapping
 * ," on page 1712
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhrr_v2, pg_buff, 0x2, 0, 6);

/* dir
 * Direction
 * 0: Ingress port quota
 * 1: Egress port quota
 * Reserved when 
 * hist_type
 *  = Queue_Latency and this field is 
 * treated as '1' Egress port quota
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhrr_v2, dir, 0x3, 0, 2);

/* hist_type
 * 0x1000: Queue_Depth_Traffic_Class
 * 0x1002: Queue_Latency
 * See 
 * Table 1101, "
 * SBHBR - Histograms Hist-type for queue histo
 * grams
 * ," on page 1262
 * Access: INDEX
 */
MLXSW_ITEM16(reg, sbhrr_v2, hist_type, 0xa, 0, 16);

/* min_sampled_high
 * min_sampled
 * Cleared when 
 * clr
 *  = 1, cleared to 0xffff_ffff_ffff_ffff
 * Units according to the units of the 
 * hist_type
 *  which is used for the 
 * hist_id
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, min_sampled_high, 0x10, 0, 32);

/* min_sampled_low
 * min_sampled
 * Cleared when 
 * clr
 *  = 1, cleared to 0xffff_ffff_ffff_ffff
 * Units according to the units of the 
 * hist_type
 *  which is used for the 
 * hist_id
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, min_sampled_low, 0x14, 0, 32);

/* max_sampled_high
 * max_sampled
 * Cleared when 
 * clr
 *  = 1, cleared to 0
 * Units according to the units of the 
 * hist_type
 *  which is used for the 
 * hist_id
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, max_sampled_high, 0x18, 0, 32);

/* max_sampled_low
 * max_sampled
 * Cleared when 
 * clr
 *  = 1, cleared to 0
 * Units according to the units of the 
 * hist_type
 *  which is used for the 
 * hist_id
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, max_sampled_low, 0x1c, 0, 32);

/* avg_sampled_high
 * Average sample
 * Average from last clear
 * When 
 * hist_type
 *  = Queue_Latency then units are 1nSec
 * Reserved when 
 * hist_type
 *  = Queue_Depth_Traffic_Class
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, avg_sampled_high, 0x20, 0, 32);

/* avg_sampled_low
 * Average sample
 * Average from last clear
 * When 
 * hist_type
 *  = Queue_Latency then units are 1nSec
 * Reserved when 
 * hist_type
 *  = Queue_Depth_Traffic_Class
 * Access: RO
 */
MLXSW_ITEM32(reg, sbhrr_v2, avg_sampled_low, 0x24, 0, 32);

/* hi
 * 
 * Access: 
 */
MLXSW_ITEM32_INDEXED(reg, sbhrr_v2, hi, MLXSW_SBHRR_V2_BIN_BASE_LEN, 0, 32, MLXSW_SBHRR_V2_BIN_REC_LEN, 0, false);

/* lo
 * 
 * Access: 
 */
MLXSW_ITEM32_INDEXED(reg, sbhrr_v2, lo, MLXSW_SBHRR_V2_BIN_BASE_LEN, 0, 32, MLXSW_SBHRR_V2_BIN_REC_LEN, 4, false);

/* pbsr
 * ----
 *
 */
/* local_port
 * Local port number.
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pbsr, local_port, 0x1, 0, 8);

/* buffer_type
 * Valid only for 8x port setting (see PMLP): 
 * 0x1 - Master buffer
 * 0x2 - Slave buffer
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pbsr, buffer_type, 0x3, 0, 2);

/* clear_wm
 * Clear watermarks for all PGs
 * Access: OP
 */
MLXSW_ITEM8(reg, pbsr, clear_wm, 0x8, 7, 1);

/* used_shared_headroom_buffer
 * Number of currently used shared headroom buffer lines.
 * Access: RO
 */
MLXSW_ITEM16(reg, pbsr, used_shared_headroom_buffer, 0xa, 0, 16);

/* watermark
 * Watermark (max buffer usage since last clear)
 * Access: RO
 */
MLXSW_ITEM16_INDEXED(reg, pbsr, watermark, MLXSW_PBSR_STAT_BUFFER_BASE_LEN + 2, 0, 16, MLXSW_PBSR_STAT_BUFFER_REC_LEN, 0, false);

/* used_buffer
 * Number of used buffer lines.
 * Access: RO
 */
MLXSW_ITEM16_INDEXED(reg, pbsr, used_buffer, MLXSW_PBSR_STAT_BUFFER_BASE_LEN + 2, 0, 16, MLXSW_PBSR_STAT_BUFFER_REC_LEN, 4, false);

/* hmon
 * ----
 *
 */
/* clr
 * Clear counters
 * Access: OP
 */
MLXSW_ITEM8(reg, hmon, clr, 0x0, 7, 1);

/* cprdq
 * Per RDQ:
 * 0: CLEAR_ALL: clear all counters of all RDQs
 * 1: CLEAR_PER_RDQ: clear counter of RQD 
 * crdq
 * Reserved when 
 * clr
 *  = 0
 * Reserved when Spectrum-1
 * Access: INDEX
 */
MLXSW_ITEM8(reg, hmon, cprdq, 0x0, 6, 1);

/* crdq
 * Clear RDQ
 * Range 0.. 
 * cap_max_num_rdq
 *  - 1
 * Reserved when 
 * clr
 *  = 0
 * Reserved when 
 * cprdq
 *  = 0
 * Reserved when Spectrum-1
 * Note: all counters are read regardless of 
 * cprdq
 *  and 
 * crdq
 * Access: INDEX
 */
MLXSW_ITEM8(reg, hmon, crdq, 0x3, 0, 6);

/* wqe_of_wrap
 * WQE overflow wrap around. The 
 * wqe_overflow
 *  had a wrap 
 * around
 * Reserved when Spectrum-2
 * Access: RO
 */
MLXSW_ITEM8(reg, hmon, wqe_of_wrap, 0x4, 7, 1);

/* wqe_overflow_high
 * WQE overflow for sum of all RDQs
 * Spectrum-1: 8bit rolling counter
 * Reserved when Spectrum-2
 * Access: RO
 */
MLXSW_ITEM32(reg, hmon, wqe_overflow_high, 0x10, 0, 32);

/* wqe_overflow_low
 * WQE overflow for sum of all RDQs
 * Spectrum-1: 8bit rolling counter
 * Reserved when Spectrum-2
 * Access: RO
 */
MLXSW_ITEM32(reg, hmon, wqe_overflow_low, 0x14, 0, 32);

/* hi
 * 
 * Access: 
 */
MLXSW_ITEM32_INDEXED(reg, hmon, hi, MLXSW_HMON_WQE_OVERFLOW_RDQ_BASE_LEN, 0, 32, MLXSW_HMON_WQE_OVERFLOW_RDQ_REC_LEN, 0, false);

/* lo
 * 
 * Access: 
 */
MLXSW_ITEM32_INDEXED(reg, hmon, lo, MLXSW_HMON_WQE_OVERFLOW_RDQ_BASE_LEN, 0, 32, MLXSW_HMON_WQE_OVERFLOW_RDQ_REC_LEN, 4, false);

/* mgpir
 * -----
 *
 */
/* device_type
 * Device type.
 * 0: No devices on system of that type.
 * 1: Vega gearbox dice
 * Access: RO
 */
MLXSW_ITEM8(reg, mgpir, device_type, 0x0, 0, 4);

/* devices_per_flash
 * Number of devices of 
 * device_type
 *  per flash.
 * Access: RO
 */
MLXSW_ITEM8(reg, mgpir, devices_per_flash, 0x1, 0, 8);

/* num_of_devices
 * Number of devices of 
 * device_type
 * .
 * Access: RO
 */
MLXSW_ITEM8(reg, mgpir, num_of_devices, 0x3, 0, 8);

/* num_of_modules
 * Number of modules.
 * Access: RO
 */
MLXSW_ITEM8(reg, mgpir, num_of_modules, 0x7, 0, 8);

/* peapbl
 * ------
 *
 */
/* region_id
 * Region identifier
 * Range 0 .. 
 * cap_max_regions
 * -1
 * Note: the register updates all duplicated regions
 * Access: INDEX
 */
MLXSW_ITEM16(reg, peapbl, region_id, 0x2, 0, 16);

/* c_s
 * Clear or set:
 * 0: prune clear
 * 1: prune set
 * Access: WO
 */
MLXSW_ITEM8(reg, peapbl, c_s, 0x10, 7, 1);

/* pruning_ctcam_cs
 * Pruning C-TCAM clear or set. Clear or set defined by 
 * c_s
 * 0: don't modify prune_ctcam bit
 * 1: modify the prune_ctcam bit
 * Access: WO
 */
MLXSW_ITEM8(reg, peapbl, pruning_ctcam_cs, 0x10, 4, 1);

/* num_rec
 * Number of records to be updated
 * Range is 1..36
 * Access: WO
 */
MLXSW_ITEM8(reg, peapbl, num_rec, 0x11, 0, 8);

/* erp_id
 * erp id
 * Access: INDEX
 */
MLXSW_ITEM8(reg, peapbl, erp_id, 0x13, 0, 4);

/* pruning_vector_cs
 * Pruning vector clear or set. Modify option defined by 
 * c_s
 * Per bit:
 * 0: don't modify pruning_vector bit
 * 1: modify the pruning_vector bit
 * Access: WO
 */
MLXSW_ITEM16(reg, peapbl, pruning_vector_cs, 0x16, 0, 16);

/* pefaad
 * ------
 *
 */
/* filter_fields
 * Filter Fields:
 * if a bit is '0' then the relevant field is ignored and dump is done 
 * regardless of the field value
 * Bit0: filter by activity: 
 * entry_a
 * Bit1: filter by action set user value: 
 * as_user_val
 * All set filters are relevant (there is AND between the filters)
 * Reserved when 
 * op
 *  is Clear activity
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pefaad, filter_fields, 0x3, 0, 8);

/* op
 * Operation
 * 0: Dump entries
 * 1: Dump entries and force end of session (clear activity will clear 
 * this session while next dump will be a new session)
 * 2: Clear activity for all entries which were dumped in the current 
 * session
 * Access: OP
 */
MLXSW_ITEM8(reg, pefaad, op, 0x4, 0, 2);

/* num_rec
 * At request: number of records requested
 * At response: number of records dumped
 * Range for request is 1..256
 * Range for response is 0..256
 * Access: OP
 */
MLXSW_ITEM16(reg, pefaad, num_rec, 0x6, 0, 9);

/* entry_a
 * Dump only if activity has value of 
 * entry_a
 * Reserved when 
 * filter_fields
 *  bit0 is '0'
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pefaad, entry_a, 0x9, 0, 1);

/* as_user_val
 * Action set user value
 * Reserved when 
 * filter_fields
 *  bit1 is '0'
 * Access: INDEX
 */
MLXSW_ITEM16(reg, pefaad, as_user_val, 0x12, 0, 10);

/* index_dump
 * 
 * Access: 
 */
MLXSW_ITEM32_INDEXED(reg, pefaad, index_dump, 0x20, 0, 24, 0x4, 0x0, false);

/* momte
 * -----
 *
 */
/* swid
 * Switch Partition ID
 * Reserved when 
 * mngr_type
 *  = LNM
 * Reserved when Ethernet switches
 * Access: INDEX
 */
MLXSW_ITEM8(reg, momte, swid, 0x0, 0, 8);

/* local_port
 * If (
 * mngr_type
 *  == "Hypervisor")
 * Unique port identifier for the final destination of the packet
 * If (
 * mngr_type
 *  == "Local Network Manager") and the port from 
 * which the command came from is InfiniBand: 
 * ib port number
 * If (
 * mngr_type
 *  == "Local Network Manager") and the port from 
 * which the command came from is Ethernet: 
 * Local Port
 * For Quantum:
 * - Supported to/from Aggregation Node
 * - Not supported to/from IB Router port
 * Access: INDEX
 */
MLXSW_ITEM8(reg, momte, local_port, 0x1, 0, 8);

/* mngr_type
 * Manager Type
 * 0: HYPERVISOR
 * 1: LNM - local network manager
 * Reserved when Spectrum
 * /-2
 * Access: OP
 */
MLXSW_ITEM8(reg, momte, mngr_type, 0x2, 0, 4);

/* type
 * Type:
 * 0x20: WRED, egress, no CPU port
 * 0x31: SHARED_BUFFER_TClass, egress
 * 0x33: 
 * SHARED_BUFFER_Egress_Port, egress
 * 0x40: ING_CONG, ingress
 * 0x50: EGR_CONG, egress
 * 0x60: ECN, egress, no CPU port
 * 0x70: HIGH_LATENCY, egress, no CPU port
 * See 
 * Section 486, "
 * Mirror triggers
 * ," on page 595
 * Access: INDEX
 */
MLXSW_ITEM8(reg, momte, type, 0x7, 0, 8);

/* tclass_en_high
 * TClass
 * /PG
 *  mirror enable (for IB switches this is VL enable)
 * Each bit represents corresponding tclass
 * 0: disable (default)
 * 1: enable
 * When type = 0x33: only bit0 is used, representing the port
 * Valid bits for Ethernet devices: 0.. 
 * cap_max_tclass_data
 *  - 1
 * Access: RW
 */
MLXSW_ITEM32(reg, momte, tclass_en_high, 0x8, 0, 32);

/* tclass_en_low
 * TClass
 * /PG
 *  mirror enable (for IB switches this is VL enable)
 * Each bit represents corresponding tclass
 * 0: disable (default)
 * 1: enable
 * When type = 0x33: only bit0 is used, representing the port
 * Valid bits for Ethernet devices: 0.. 
 * cap_max_tclass_data
 *  - 1
 * Access: RW
 */
MLXSW_ITEM32(reg, momte, tclass_en_low, 0xc, 0, 32);

/* reiv
 * ----
 *
 */
/* erif
 * egress RIF
 * Range is 0.. 
 * cap_max_router_interfaces
 * -1
 * Access: INDEX
 */
MLXSW_ITEM16(reg, reiv, erif, 0x6, 0, 16);

/* update
 * Update enable (when write):
 * 0: do not update the entry
 * 1: update the entry
 * Access: OP
 */
MLXSW_ITEM8_INDEXED(reg, reiv, update, MLXSW_REIV_ELPORT_RECORD_BASE_LEN, 7, 1, MLXSW_REIV_ELPORT_RECORD_REC_LEN, 0, false);

/* evid
 * egress vid, range 0..4095
 * Access: RW
 */
MLXSW_ITEM16_INDEXED(reg, reiv, evid, MLXSW_REIV_ELPORT_RECORD_BASE_LEN + 2, 0, 12, MLXSW_REIV_ELPORT_RECORD_REC_LEN, 0, false);

/* svfa
 * ----
 *
 */
/* swid
 * Switch partition ID
 * Reserved when Spectrum/-2
 * Access: INDEX
 */
MLXSW_ITEM8(reg, svfa, swid, 0x0, 0, 8);

/* local_port
 * Local port number
 * Reserved when 
 * mapping_table
 *  = '0' (VLAN mapping)
 * Reserved when 
 * mapping_table
 *  = '2' (VNI mapping)
 * Access: INDEX
 */
MLXSW_ITEM8(reg, svfa, local_port, 0x1, 0, 8);

/* mapping_table
 * Mapping table:
 * 0: VLAN_mapping_table - VID to FID mapping
 * 1: Port_VLAN_mapping_table - {Port,VID} to FID mapping
 * 2: VNI_mapping_table - VNI to FID mapping. Reserved when 
 * ubridge 
 * = 0
 * Access: INDEX
 */
MLXSW_ITEM8(reg, svfa, mapping_table, 0x2, 0, 3);

/* v
 * Valid
 * Indicates the VID to FID mapping entry is valid. 
 * Reserved when SwitchX/-2, where entries are always valid and 
 * can not be invalidated regardless of the 
 * v
 *  bit value.
 * Access: RW
 */
MLXSW_ITEM8(reg, svfa, v, 0x3, 0, 1);

/* fid
 * Filtering ID
 * Cannot be modified for a valid (
 * v
 * =1) mapping
 * Reserved when 
 * trap_action
 *  is TRAP or DISCARD_ERROR
 * Access: RW
 */
MLXSW_ITEM16(reg, svfa, fid, 0x4, 0, 16);

/* vid
 * VLAN ID
 * Reserved when 
 * mapping_table
 *  = '2' (VNI mapping)
 * Access: INDEX
 */
MLXSW_ITEM16(reg, svfa, vid, 0x6, 0, 12);

/* counter_set_type
 * Counter Set Type for flow counters.
 * For Spectrum/-2: See 
 * Section 4.2.2, "
 * Counter Set Type
 * ," on 
 * page 588
 * Spectrum-2: Note that for router-sub-port, at the FID after routing 
 * there is no counting. If need counter then use fid-rif
 * Reserved when SwitchX/-2
 * Access: RW
 */
MLXSW_ITEM8(reg, svfa, counter_set_type, 0x8, 0, 8);

/* counter_index
 * Counter Index for flow counters.
 * For Spectrum/-2: see 
 * Section 4.2, "
 * Flow Counters
 * ," on page 588
 * Reserved when SwitchX/-2
 * Access: RW
 */
MLXSW_ITEM32(reg, svfa, counter_index, 0x8, 0, 24);

/* trap_action
 * Trap Action
 * 0x0: NOP
 * 0x1: TRAP
 * 0x2: MIRROR_TO_CPU
 * 0x3: MIRROR
 * 0x4: DISCARD_ERROR
 * For TRAP and MIRROR_TO_CPU the trap-ID is FID_TRAP
 * Reserved when SwitchX/-2
 * Spectrum-2
 *  - n
 * ote that for router-sub-port, at the FID after routing 
 * there is no trap (behavior is NOP). If need trap then use fid-rif
 * Access: RW
 */
MLXSW_ITEM8(reg, svfa, trap_action, 0xc, 4, 4);

/* vni
 * vni
 * Reserved when 
 * mapping_table
 *  != '2' (VNI mapping table)
 * Access: INDEX
 */
MLXSW_ITEM32(reg, svfa, vni, 0x10, 0, 24);

/* irif_v
 * Ingress RIF valid:
 * 0: irif is not valid, no irif assigned
 * 1: irif valid
 * Must not be set for a non enabled RIF
 * Reserved when 
 * ubridge 
 * = 0
 * Access: RW
 */
MLXSW_ITEM8(reg, svfa, irif_v, 0x14, 0, 1);

/* irif
 * Ingress RIF (Router Interface)
 * Range is 0.. 
 * cap_max_router_interfaces
 * -1
 * Reserved when 
 * ubridge 
 * = 0
 * Reserved when 
 * irif_v 
 * = 0
 * Access: RW
 */
MLXSW_ITEM16(reg, svfa, irif, 0x16, 0, 16);

/* smpe
 * ----
 *
 */
/* local_port
 * Local port number
 * CPU port is not supported
 * Access: INDEX
 */
MLXSW_ITEM8(reg, smpe, local_port, 0x1, 0, 8);

/* smpe_index
 * Switch multicast port to egress VID
 * Range is 0.. 
 * cap_max_rmpe
 *  - 1
 * Note: when 
 * ubridge
 * =1 the rmpe and smpe use the same range, see 
 * RMPE register
 * Access: INDEX
 */
MLXSW_ITEM16(reg, smpe, smpe_index, 0x6, 0, 16);

/* evid
 * Egress VID
 * Access: RW
 */
MLXSW_ITEM16(reg, smpe, evid, 0xa, 0, 12);

/* mafri
 * -----
 *
 */
/* num_rec
 * Number of records to read
 * Range 1..128
 * Access: OP
 */
MLXSW_ITEM8(reg, mafri, num_rec, 0x3, 0, 8);

/* counter_index_base
 * Counter Index base
 * Counters will be read starting at 
 * counter_index_base
 * Must have a value of 32*N 
 * Range: 
 * cap_start_accuflow
 *  .. 
 * cap_max_accuflow
 *  - 1
 * Note: 
 * counter_index_base
 *  + 
 * num_rec
 *  must be equal or lower 
 * than 
 * cap_max_accuflow
 * Access: OP
 */
MLXSW_ITEM32(reg, mafri, counter_index_base, 0x4, 0, 24);

/* bytes_inc
 * Bytes to increment to bytes counter
 * Unit of 512B
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, mafri, bytes_inc, MLXSW_MAFRI_RECORD_BASE_LEN, 0, 32, MLXSW_MAFRI_RECORD_REC_LEN, 0, false);

/* packets_inc
 * Packets to increment to packets counter
 * Unit is 4packets
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, mafri, packets_inc, MLXSW_MAFRI_RECORD_BASE_LEN, 0, 32, MLXSW_MAFRI_RECORD_REC_LEN, 4, false);

/* mcc
 * ---
 *
 */
/* time_elapsed_since_last_cmd
 * The number of seconds elapsed since the update_handle 
 * owner last issued a command. The time saturates at 0xFFF.
 * Access: RO
 */
MLXSW_ITEM16(reg, mcc, time_elapsed_since_last_cmd, 0x0, 0, 12);

/* instruction
 * Command to be executed by the FSM
 * 0x1: LOCK_UPDATE_HANDLE
 * 0x2: RELEASE_UPDATE_HANDLE 
 * 0x3: UPDATE_COMPONENT
 * 0x4: VERIFY_COMPONENT
 * 0x5: ACTIVATE_COMPONENET 
 * 0x6: ACTIVATE
 * 0x7: READ_COMPONENT
 * 0x8: CANCEL
 * 0x9: CHECK_UPDATE_HANDLE
 * 0xA: FORCE_HANDLE_RELEASE
 * 0xB: READ_PENDING_COMPONENT
 * Other values are reserved. Applicable for write operation 
 * only.
 * Access: RW
 */
MLXSW_ITEM8(reg, mcc, instruction, 0x3, 0, 8);

/* component_index
 * Index of the accessed component. Valid for 
 * UPDATE_COMPONENT, ACTIVATE_COMPONENET, 
 * READ_COMPONENT and READ_PENDING_COMPO
 * NENT instructions. Otherwise, this field is reserved.
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mcc, component_index, 0x6, 0, 16);

/* update_handle
 * Token representing the current flow executed by the FSM.
 * Access: RW
 */
MLXSW_ITEM32(reg, mcc, update_handle, 0x8, 0, 24);

/* handle_owner_type
 * Type of entity holding the update handle:
 * 0x0: unspecified
 * 0x1: Chassis BMC
 * 0x2: MAD
 * 0x3: BMC
 * 0x4: command interface
 * 0x5: ICMD 
 * Other values are reserved.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcc, handle_owner_type, 0xc, 4, 4);

/* handle_owner_host_id
 * For 
 * handle_owner_type
 *  BMC, command-interface and 
 * ICMD, indicates the identifier of the host of the handle 
 * owner.
 * Otherwise reserved
 * Access: RO
 */
MLXSW_ITEM8(reg, mcc, handle_owner_host_id, 0xc, 0, 4);

/* control_progress
 * Indicates the estimated progress status of the current opera
 * tion executed by the FSM. Valid values are 0..100.
 * 101 indicates that progress reporting is not supported for 
 * this update state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcc, control_progress, 0xd, 0, 7);

/* error_code
 * Indicates the successful completion of the 
 * instruction
 * , or 
 * the reason it failed. 
 * 0x0: OK
 * 0x1: ERROR
 * 0x2: REJECTED_DIGEST_ERR
 * 0x3: REJECTED_NOT_APPLICABLE
 * 0x4: REJECTED_UNKNOWN_KEY
 * 0x5: REJECTED_AUTH_FAILED
 * 0x6: REJECTED_UNSIGNED
 * 0x7: REJECTED_KEY_NOT_APPLICABLE
 * 0x8: REJECTED_BAD_FORMAT
 * 0x9: BLOCKED_PENDING_RESET
 * 0xA: REJECTED_NOT_A_SECURED_FW
 * 0xB: REJECTED_MFG_BASE_MAC_NOT_LISTED
 * 0xC: REJECTED_NO_DEBUG_TOKEN
 * 0xD: REJECTED_VERSION_NUM_MISMATCH
 * 0xE: REJECTED_USER_TIMESTAMP_MISMATCH
 * 0xF: REJECTED_FORBIDDEN_VERSION
 * 0x10: FLASH_ERASE_ERROR
 * 0x11: REJECTED_REBURN_RUNNING_AND_RETRY
 * Other values should be treated as an unknown error.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcc, error_code, 0xe, 0, 8);

/* control_state
 * Current Update FSM state
 * 0x0: IDLE
 * 0x1: LOCKED
 * 0x2: INITIALIZE
 * 0x3: DOWNLOAD
 * 0x4: VERIFY
 * 0x5: APPLY
 * 0x6: ACTIVATE
 * 0x7: UPLOAD
 * 0x8: UPLOAD_PENDING
 * Other values are reserved
 * Access: RO
 */
MLXSW_ITEM8(reg, mcc, control_state, 0xf, 0, 4);

/* component_size
 * Component size in bytes. 
 * Valid for UPDATE_COMPONENT instruction. Specify
 * ing the size may shorten the update time.
 * Value 0x0 means that size is unspecified.
 * Access: WO
 */
MLXSW_ITEM32(reg, mcc, component_size, 0x10, 0, 32);

/* device_index
 * Device number.
 * For gearboxes, the index represents the gearbox die.
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mcc, device_index, 0x14, 0, 12);

/* device_type
 * Peripheral device type:
 * 0: Switch / NIC
 * 1: Gearbox
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mcc, device_type, 0x17, 0, 8);

/* sfdb
 * ----
 *
 */
/* update_type
 * Update type:
 * 0: Update Multicast_Tunnel_FDB_record.
 * underlay_mc_ptr
 * 1: Update Multicast_FDB_record.
 * mid
 *  and Update Multicast
 * _Tunnel_FDB_record.
 * mid
 * See 
 * Section 6.2.15, "
 * FDB Records
 * ," on page 759
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sfdb, update_type, 0xb, 0, 4);

/* entry_fid
 * Update only if FID has value of 
 * entry_fid
 * Range 1..
 * cap_fid
 * -1
 * Access: INDEX
 */
MLXSW_ITEM16(reg, sfdb, entry_fid, 0xe, 0, 16);

/* parameter
 * For 
 * update_type
 *  = 0:
 * - Multicast_Tunnel_FDB_record.
 * underlay_mc_ptr
 *  (24bit)
 * For 
 * update_type
 *  = 1:
 * - Multicast_FDB_record.
 * mid
 *  (16bit)
 * - Multicast_Tunnel_FDB_record.
 * mid
 *  (16bit)
 * Access: INDEX
 */
MLXSW_ITEM32(reg, sfdb, parameter, 0x20, 0, 32);

/* new_parameter
 * New parameter
 * For 
 * update_type
 *  = 0:
 * - Multicast_Tunnel_FDB_record.
 * underlay_mc_ptr
 *  (24bit)
 * For 
 * update_type
 *  = 1:
 * - Multicast_FDB_record.
 * mid
 *  (16bit)
 * - Multicast_Tunnel_FDB_record.
 * mid
 *  (16bit)
 * Access: WO
 */
MLXSW_ITEM32(reg, sfdb, new_parameter, 0x40, 0, 32);

/* mcda
 * ----
 *
 */
/* update_handle
 * Update handle registered when the FSM was activated.
 * Access: RW
 */
MLXSW_ITEM32(reg, mcda, update_handle, 0x0, 0, 24);

/* offset
 * Offset of accessed address relative to component start. 
 * Accesses must be in accordance to 
 * log_mcda_word_size
 *  in 
 * Table 1261, "
 * MCQI CAPABILITIES Info Layout
 * ," on 
 * page 1355
 * Access: RW
 */
MLXSW_ITEM32(reg, mcda, offset, 0x4, 0, 32);

/* size
 * Size of the data accessed, given in bytes
 * Access: RW
 */
MLXSW_ITEM16(reg, mcda, size, 0xa, 0, 16);

/* data
 * Data block accessed
 * Access: RW
 */
MLXSW_ITEM32_INDEXED(reg, mcda, data, 0x10, 0, 32, 4, 0, false);

/* rmftad
 * ------
 *
 */
/* op
 * 0: Read activity
 * 1: Read and clear activity
 * Access: OP
 */
MLXSW_ITEM8(reg, rmftad, op, 0x0, 6, 2);

/* type
 * Entry Type:
 * 0: Multicast IPv4
 * 1: Multicast IPv6
 * Access: INDEX
 */
MLXSW_ITEM8(reg, rmftad, type, 0x1, 4, 2);

/* offset
 * Offset within the multicast forwarding table
 * Must be N*32
 * Access: INDEX
 */
MLXSW_ITEM16(reg, rmftad, offset, 0x2, 0, 16);

/* num_rec
 * Number of records to read
 * Range 1..4096
 * Access: OP
 */
MLXSW_ITEM16(reg, rmftad, num_rec, 0x6, 0, 13);

/* activity_vector
 * Activity per offset
 * Line 20h bit 31 is for entry 
 * offset+
 * 4095
 * Line 21C bit 0 is for entry 
 * offset+
 * 0
 * Bits higher than 
 * num_rec 
 * are reserved
 * Bits higher than region_size
 *  
 * are reserved
 * For non-valid offsets the activity is reserved
 * Access: RO
 */
MLXSW_ITEM32_INDEXED(reg, rmftad, activity_vector, 0x20, 0, 32, 4, 0, false);

/* sfgc
 * ----
 *
 */
/* type
 * 0: BROADCAST
 * 1: UNKNOWN_UNICAST
 * 2: UNREGISTERED_MULTICAST_IPV4
 * 3: UNREGISTERED_MULTICAST_IPV6
 * 4: RESERVED
 * 5: UNREGISTERED_MULTICAST_NON_IP
 * 6: IPV4_LINK_LOCAL - (Addresses 224.0.0.X), not supported by 
 * SwitchX/-2
 * 7: IPV6_ALL_HOSTS - (Address FF02::1), not supported by 
 * SwitchX/-2
 * Other - reserved
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sfgc, type, 0x3, 0, 4);

/* bridge_type
 * Bridge Type (see 
 * Section 6.4.2.1, "
 * FID Classification
 * ," on 
 * page 788
 * ):
 * 0: type0 - when 
 * ubridge
 * =0: 802.1Q. FID
 * 1: type1 - when 
 * ubridge
 * =0: vFID. Reserved when SwitchX/-2
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sfgc, bridge_type, 0x4, 0, 3);

/* table_type
 * Table type to use:
 * 0: any_type - should only be used if only one type of table is con
 * figured in the profile. Reserved when Spectrum/-2
 * 1: per_VID_tables - reserved when 
 * ubridge
 * =1
 * 2: single_entry_tables - reserved when 
 * ubridge
 * =1
 * 3: FID_Offset - reserved when SwitchX/-2
 * 4: FID - (when 
 * ubridge
 * =0 used for vFIDs only, not for the first 4K 
 * FIDs). Reserved when SwitchX/-2
 * Access: RW
 */
MLXSW_ITEM8(reg, sfgc, table_type, 0x5, 0, 3);

/* flood_table
 * Flooding table index to associate with the specific type on the spe
 * cific switch partition.
 * If 
 * table_type
 *  == single entry:
 * Indexed from 0 to 
 * max_flood_tables
 * -1
 * If 
 * table_type
 *  == VID:
 * Indexed from 0 to 
 * max_vid_flood_tables
 * -1
 * If 
 * table_type
 *  == FID_Offset (when 
 * ubridge
 * =0 supports VIDs):
 * Indexed from 0 to 
 * max_fid_offset_flood_tables
 * -1
 * If 
 * table_type
 *  == FID (when 
 * ubridge
 * =0 supports and used only 
 * vFIDs):
 * Indexed from 0 to 
 * max_fid_flood_tables
 * -1
 * Reserved when 
 * ubridge
 * =1
 * Access: RW
 */
MLXSW_ITEM8(reg, sfgc, flood_table, 0x7, 0, 6);

/* counter_set_type
 * Counter Set Type for flow counters.
 * For Spectrum/-2: See 
 * Section 4.2.2, "
 * Counter Set Type
 * ," on 
 * page 588
 * Not supported by SwitchX/-2
 * Access: RW
 */
MLXSW_ITEM8(reg, sfgc, counter_set_type, 0xc, 0, 8);

/* counter_index
 * Counter Index for flow counters.
 * For Spectrum/-2: See 
 * Section 4.1, "
 * Performance and Monitoring 
 * Counters
 * ," on page 587
 * Not supported by SwitchX/-2
 * Access: RW
 */
MLXSW_ITEM32(reg, sfgc, counter_index, 0xc, 0, 24);

/* mid_base
 * MID Base
 * Reserved when 
 * ubridge
 * =0
 * Access: RW
 */
MLXSW_ITEM16(reg, sfgc, mid_base, 0x12, 0, 16);

/* sbhbr_v2
 * --------
 *
 */
/* local_port
 * Local port number.
 * For Ingress: excludes CPU port and Router port
 * For Egress: excludes IP Router
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhbr_v2, local_port, 0x1, 0, 8);

/* pg_buff
 * PG buffer - Port PG (
 * dir
 * =ingress) / traffic class (
 * dir
 * =egress)
 * For PG buffer: range is 0..
 * cap_max_pg_buffers
 *  - 1
 * For traffic class: range is 0..
 * cap_max_tclass
 *  - 1
 * For traffic class to CPU port: range is 0..
 * cap_max_cpu_in
 * gress_tclass
 * - 1
 * For Spectrum: no admission on Tx.Tclass, so when traffic class is 
 * in MC aware mode then the traffic classes which are MC aware 
 * must not be configured, but can be read. 
 * Spectrum-2 has admis
 * sion on Tx.Tclass so all traffic classes can be configured also for 
 * MC aware mode. 
 * see 
 * Section 11.5, "
 * Ethernet Switch Packet Priority and TClass 
 * Mapping," on page 1712
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhbr_v2, pg_buff, 0x2, 0, 6);

/* dir
 * Direction
 * 0: Ingress port quota
 * 1: Egress port quota
 * Reserved when 
 * hist_type
 *  = Queue_Latency and this field is 
 * treated as '1' Egress port quota
 * Access: INDEX
 */
MLXSW_ITEM8(reg, sbhbr_v2, dir, 0x3, 0, 2);

/* en
 * Enable the histogram
 * Access: RW
 */
MLXSW_ITEM8(reg, sbhbr_v2, en, 0x7, 0, 1);

/* mode
 * mode
 * 0: Linear histogram
 * 1: Exponential histogram
 * Access: RW
 */
MLXSW_ITEM8(reg, sbhbr_v2, mode, 0x8, 4, 3);

/* hist_type
 * 0x1000: Queue_Depth_Traffic_Class
 * 0x1002: Queue_Latency
 * See 
 * Table 1101, "
 * SBHBR - Histograms Hist-type for queue histo
 * grams
 * ," on page 1262
 * Access: INDEX
 */
MLXSW_ITEM16(reg, sbhbr_v2, hist_type, 0xa, 0, 16);

/* hist_min_value
 * Min value for histogram main range
 * Units according to the units of the 
 * hist_type
 * Access: RW
 */
MLXSW_ITEM32(reg, sbhbr_v2, hist_min_value, 0x10, 0, 32);

/* hist_max_value
 * Max value for histogram main range
 * When 
 * mode
 * =0 (linear), then
 *  
 * this rule must be meet:
 * hist_max_value
 *  = 
 * hist_min_value
 *  + 2^n, n >= 3
 * When 
 * mode
 * =1 (exponential), then this rule must be meet:
 * hist_max_value
 *  = 
 * hist_min_value
 *  + 255*2^n, n >= 0
 * Units according to the units of the 
 * hist_type
 * Access: RW
 */
MLXSW_ITEM32(reg, sbhbr_v2, hist_max_value, 0x14, 0, 32);

/* sample_time
 * Sample time interval. 
 * Allowed range:
 * time = 2^
 * sample_time
 *  * 128nSec
 * sample_time
 *  range is 0..
 * cap_max_sample_time
 * -1
 * For Spectrum-1 the 
 * sample_time
 *  is global for all ports and all 
 * tclass 
 * For Spectrum-2 the sample_time is per port.tclass. 
 * Reserved when 
 * hist_type
 *  = Queue_Latency
 * Access: RW
 */
MLXSW_ITEM8(reg, sbhbr_v2, sample_time, 0x1b, 0, 6);

/* mcqi
 * ----
 *
 */
/* read_pending_component
 * When set, the register will return information about the 
 * pending component (if available)
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mcqi, read_pending_component, 0x0, 7, 1);

/* device_index
 * Device number.
 * For gearboxes, the index represents the gearbox die.
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mcqi, device_index, 0x0, 0, 12);

/* component_index
 * Component index gathered by 
 * "
 * MCQS - Management 
 * Component Query Status
 * "
 * Access: INDEX
 */
MLXSW_ITEM16(reg, mcqi, component_index, 0x2, 0, 16);

/* device_type
 * Peripheral device type:
 * 0: Switch / NIC
 * 1: Gearbox
 * Access: INDEX
 */
MLXSW_ITEM8(reg, mcqi, device_type, 0x7, 0, 8);

/* info_type
 * Component properties set.
 * 0x0: CAPABILITIES
 * 0x1: VERSION
 * 0x5: ACTIVATION_METHOD
 * Other values are reserved
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, info_type, 0xb, 0, 5);

/* info_size
 * Properties set structure size, given in bytes.
 * Access: RO
 */
MLXSW_ITEM32(reg, mcqi, info_size, 0xc, 0, 32);

/* offset
 * The requested/returned data offset from the section start, 
 * given in bytes.
 * Must be DWORD aligned.
 * Access: RW
 */
MLXSW_ITEM32(reg, mcqi, offset, 0x10, 0, 32);

/* data_size
 * The requested/returned data size, given in bytes.
 * If 
 * data_size
 *  is not DWORD aligned, the last bytes are zero 
 * padded.
 * Access: RW
 */
MLXSW_ITEM16(reg, mcqi, data_size, 0x16, 0, 16);

/* mcqi_cap_supported_info_bitmask
 * Bitmask indicating which info_type(s) are supported for 
 * this component. Set bit indicates the property set is sup
 * ported
 * bit 1: VERSION
 * bit 5: ACTIVATION_METHOD
 * Other bits are reserved. CAPABILITIES set is always sup
 * ported.
 * Access: RO
 */
MLXSW_ITEM32(reg, mcqi, mcqi_cap_supported_info_bitmask, 0x18, 0, 32);

/* mcqi_cap_component_size
 * The size of the component given in bytes. Value 0x0 indi
 * cates that the size in unknown.
 * For some components, size may only be available in the 
 * READ_COMPONENT state.
 * Access: RO
 */
MLXSW_ITEM32(reg, mcqi, mcqi_cap_component_size, 0x1c, 0, 32);

/* mcqi_cap_max_component_size
 * Maximum size for this component, given in bytes.
 * Access: RO
 */
MLXSW_ITEM32(reg, mcqi, mcqi_cap_max_component_size, 0x20, 0, 32);

/* mcqi_cap_log_mcda_word_size
 * Log 2 of the access word size in bytes.
 * Read and write access must be aligned to the word size. 
 * Write access must be done for an integer number of words.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_log_mcda_word_size, 0x24, 4, 4);

/* mcqi_cap_mcda_max_write_size
 * Maximal write size for MCDA
 * Access: RO
 */
MLXSW_ITEM16(reg, mcqi, mcqi_cap_mcda_max_write_size, 0x26, 0, 16);

/* mcqi_cap_rd_en
 * When set, this components may be read
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_rd_en, 0x28, 7, 1);

/* mcqi_cap_signed_updates_only
 * Only signed components are accepted.
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_signed_updates_only, 0x28, 6, 1);

/* mcqi_cap_match_chip_id
 * Chip ID (
 * device_hw_revision
 * ) is validated for this compo
 * nent update.
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_match_chip_id, 0x28, 5, 1);

/* mcqi_cap_match_psid
 * PSID is validated for this component update.
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_match_psid, 0x28, 4, 1);

/* mcqi_cap_check_user_timestamp
 * A user defined timestamp (MVTS) is active for this compo
 * nent.
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_check_user_timestamp, 0x28, 3, 1);

/* mcqi_cap_match_base_guid_mac
 * The device only accepts updates for this component that 
 * explicitly lists its base MAC and/or base GUID
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_cap_match_base_guid_mac, 0x28, 2, 1);

/* mcqi_version_build_time_valid
 * When set, the component has a valid creation time-stamp in 
 * build_time
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_version_build_time_valid, 0x18, 5, 1);

/* mcqi_version_user_defined_time_valid
 * When set, the component has a valid user-defined version 
 * time-stamp in 
 * user_defined_time
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_version_user_defined_time_valid, 0x18, 4, 1);

/* mcqi_version_version_string_length
 * 
 * Access: RW
 */
MLXSW_ITEM8(reg, mcqi, mcqi_version_version_string_length, 0x1b, 0, 8);

/* mcqi_version_version
 * Version number
 * Access: RW
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_version, 0x1c, 0, 32);

/* mcqi_version_build_time_hi
 * 
 * Access: 
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_build_time_hi, 0x20, 0, 32);

/* mcqi_version_build_time_lo
 * 
 * Access: 
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_build_time_lo, 0x24, 0, 32);

/* mcqi_version_user_defined_time_hi
 * 
 * Access: 
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_user_defined_time_hi, 0x28, 0, 32);

/* mcqi_version_user_defined_time_lo
 * 
 * Access: 
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_user_defined_time_lo, 0x2c, 0, 32);

/* mcqi_version_build_tool_version
 * Build tool version number.
 * Valid only when not equal to 0
 * Access: RW
 */
MLXSW_ITEM32(reg, mcqi, mcqi_version_build_tool_version, 0x30, 0, 32);

/* mcqi_version_version_string
 * NULL terminated string representing the version.
 * Access: RW
 */
MLXSW_ITEM_BUF(reg, mcqi, mcqi_version_version_string, 0x38, 92);

/* mcqi_activation_method_pending_server_ac_power_cycle
 * This component goes to ACTIVE_PENDING_RESET state 
 * after activation.
 * AC power cycle (power cycle for both PCI power rails and 
 * AUX power), will move it ACTIVE state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_pending_server_ac_power_cycle, 0x18, 7, 1);

/* mcqi_activation_method_pending_server_dc_power_cycle
 * This component goes to ACTIVE_PENDING_RESET state 
 * after activation.
 * DC power cycle (power cycle of PCI power rails), will 
 * move it ACTIVE state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_pending_server_dc_power_cycle, 0x18, 6, 1);

/* mcqi_activation_method_pending_server_reboot
 * This component goes to ACTIVE_PENDING_RESET state 
 * after activation.
 * A server reset (PCIe PERST#), will move it ACTIVE state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_pending_server_reboot, 0x18, 5, 1);

/* mcqi_activation_method_pending_fw_reset
 * This component goes to ACTIVE_PENDING_RESET after 
 * activation.
 * A FW reset will move it to ACTIVE state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_pending_fw_reset, 0x18, 4, 1);

/* mcqi_activation_method_auto_activate
 * This component will be ACTIVE or ACTIVE_PEND
 * ING_RESET after the APPLY state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_auto_activate, 0x18, 3, 1);

/* mcqi_activation_method_all_hosts_sync
 * When set, the operation needed to move the component 
 * form ACTIVE_PENDING_RESET to ACTIVE should 
 * happen simultaneously on all hosts.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_all_hosts_sync, 0x18, 2, 1);

/* mcqi_activation_method_device_hw_reset
 * This component goes to ACTIVE_PENDING_RESET after 
 * activation.
 * A HW reset will move it to ACTIVE state.
 * Access: RO
 */
MLXSW_ITEM8(reg, mcqi, mcqi_activation_method_device_hw_reset, 0x18, 1, 1);

/* pmtps
 * -----
 *
 */
/* module
 * Module number.
 * Access: INDEX
 */
MLXSW_ITEM8(reg, pmtps, module, 0x1, 0, 8);

/* module_type_admin
 * Module type enabled (bitmask):
 * Bit 0 - SMF (Single Mode Fiber) Module up to 500m
 * Bit 1 - SMF (Single Mode Fiber) Module between 500m and 2km
 * Bit 2 - SMF (Single Mode Fiber) Module above 2km
 * Bit 3 - MMF (Multi Mode Fiber) Module up to 100m
 * Bit 4 - MMF (Multi Mode Fiber) Module above 100m
 * Bit 5 - AOC / ACC up to 30m 
 * Bit 6 - AOC / ACC above 30m 
 * Bit 7 - Passive Copper
 * Bit 8 - Twisted Pair
 * Bit 9 - Backplane 
 * Set a value of 0xFFFF enables all PMDs type (including of unknowns 
 * types)
 * Access: RW
 */
MLXSW_ITEM16(reg, pmtps, module_type_admin, 0xa, 0, 16);

/* module_type_connected
 * Connected and operational PMD type:
 * 0x0 - Unknown / Not Connected
 * 0x1 - SMF (Single Mode Fiber) Module up to 500m
 * 0x2 - SMF (Single Mode Fiber) Module up to 2km
 * 0x4 - SMF (Single Mode Fiber) Module above 2km
 * 0x8 - MMF (Multi Mode Fiber) Module up to 100m
 * 0x10 - MMF (Multi Mode Fiber) Module above 100m
 * 0x20 - AOC / ACC up to 30m
 * 0x40 - AOC / ACC up to 30m
 * 0x80 - Passive copper 
 * 0x100 - Twisted Pair
 * 0x200 - Backplane
 * Access: RO
 */
MLXSW_ITEM16(reg, pmtps, module_type_connected, 0xe, 0, 16);

/* eth_module_c2m
 * Supported Module electrical interfaces: 
 * Bit 0 - SGMII_100M
 * Bit 1 - 1000BASE-X / SGMII
 * Bit 3 - 5GBASE-R
 * Bit 4 - XFI / SFI // 10G
 * Bit 5 - XLAUI-4/XLPPI-4 // 40G 
 * Bit 6 - 25GAUI-1/ 25GBASE-CR / KR 
 * Bit 7 - 50GAUI-2 / LAUI-2/ 50GBASE-CR2/KR2 
 * Bit 8 - 50GAUI-1 / LAUI-1/ 50GBASE-CR / KR
 * Bit 9 - CAUI-4 / 100GBASE-CR4 / KR4
 * Bit 10 - 100GAUI-2 / 100GBASE-CR2 / KR2 
 * Bit 11 - Reserved 
 * Bit 12 - 200GAUI-4 / 200GBASE-CR4/KR4
 * Bit 13 - Reserved 
 * Bit 14 - Reserved
 * Bit 15 - 400GAUI-8
 * Other - Reserved
 * Access: RO
 */
MLXSW_ITEM32(reg, pmtps, eth_module_c2m, 0x10, 0, 32);

