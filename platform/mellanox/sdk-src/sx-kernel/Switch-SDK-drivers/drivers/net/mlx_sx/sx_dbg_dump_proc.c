/*
 * Copyright (c) 2010-2019,  Mellanox Technologies. All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directory of this source tree, or the
 * OpenIB.org BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/kallsyms.h>
#include <linux/mlx_sx/kernel_user.h>
#include "sx.h"
#include "alloc.h"
#include "sx_dbg_dump_proc.h"

/************************************************
 *  MACROS
 ***********************************************/

#define DBG_DUMP_BUFF_SIZE 80
#define SEQ_FILE_SIZE      (64 * 1024)

/************************************************
 *  GLOBAL VARIABLES
 ***********************************************/

extern struct sx_globals sx_glb;

/************************************************
 *  LOCAL VARIABLES
 ***********************************************/
struct proc_dir_entry *__root_dir = NULL;
static u8              sx_dbg_dump_proc_registered = 0;
static struct mutex    __proc_list_lock;
static LIST_HEAD(__proc_list);

struct proc_info {
    struct list_head        list;
    dbg_dump_proc_show_cb_t show_cb;
    dbg_dump_proc_size_cb_t size_cb;
    char                   *name;
};

#define TRAP_UNKNOWN_STR       "Unknown"
#define TRAP_ACL_OR_ROUTER_STR "ACL or Router trap"
#define TRAP_ANY_STR           "Any trap"

/*
 * trap_ids string is defined as static string array because traps range isn't continuous
 */
static const char * const sxd_trap_id_str_s[] = {
    /* GENERAL */
    [SXD_TRAP_ID_GENERAL_FDB] = "SXD_GENERAL_FDB",           /**< FDB */
    [SXD_TRAP_ID_GENERAL_DR_IPC] = "SXD_DR_IPC",      /**< DR IPC */
    [SXD_TRAP_ID_GENERAL_DR_RES] = "SXD_DR_RES",      /**< DR RES */
    [SXD_TRAP_ID_GENERAL_ETH_EMAD] = "SXD_ETH_EMAD",   /**< ETHERNET EMAD */
    [SXD_TRAP_ID_FDB] = "SXD_FDB",                     /**< FDB TRAP */

    /* EVENTS */
    [SXD_TRAP_ID_PUDE] = "SXD_PUDE",                   /**< port up/down*/
    [SXD_TRAP_ID_PMPE] = "SXD_PMPE",                   /**< port module plug / unplug */
    [SXD_TRAP_ID_FLAE] = "SXD_FLAE",                   /**< FDB learning and aging event */
    [SXD_TRAP_ID_TMPW] = "SXD_TMPW",                   /**< Temperature warning event */
    [SXD_TRAP_ID_CPUWD] = "SXD_CPUWD",                 /**< CPU Watchdog Event */
    [SXD_TRAP_ID_FORE] = "SXD_FORE",                   /**< Fan Out of Rang event generated by hardware */
    [SXD_TRAP_ID_PPBME] = "SXD_PPBME",                  /**< BER monitor trap */
    [SXD_TRAP_ID_PACKET_RECEIVED] = "SXD_PACKET_RECEIVED",

    /* ETHERNET L2 */
    [SXD_TRAP_ID_ETH_L2_STP] = "SXD_STP",                /**< ETHERNET L2 STP */
    [SXD_TRAP_ID_ETH_L2_LACP] = "SXD_LACP",               /**< ETHERNET L2 LACP */
    [SXD_TRAP_ID_ETH_L2_EAPOL] = "SXD_EAPOL",              /**< ETHERNET L2 EAPOL */
    [SXD_TRAP_ID_ETH_L2_LLDP] = "SXD_LLDP",               /**< ETHERNET L2 LLDP */
    [SXD_TRAP_ID_ETH_L2_MMRP] = "SXD_MMRP",               /**< ETHERNET L2 MMRP */
    [SXD_TRAP_ID_ETH_L2_MVRP] = "SXD_MVRP",               /**< ETHERNET L2 MVRP */
    [SXD_TRAP_ID_ETH_L2_RPVST] = "SXD_RPVST",              /**< ETHERNET L2 RPVST */

    /* PTP traps */
    [SXD_TRAP_ID_PTP_PTP0] = "SXD_PTP0_EVENT",
    [SXD_TRAP_ID_PTP_PTP1] = "SXD_PTP1_GENERAL",
    [SXD_TRAP_ID_PTP_ING_EVENT] = "SXD_PTP_ING_EVENT",
    [SXD_TRAP_ID_PTP_EGR_EVENT] = "SXD_PTP_EGR_EVENT",

    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_QUERY] = "SXD_IGMP_QUERY",    /**< ETHERNET L2 IGMP QUERY */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V1_REPORT] = "SXD_IGMP_V1_REPORT", /**< ETHERNET L2 IGMP V1_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_REPORT] = "SXD_IGMP_V2_REPORT", /**< ETHERNET L2 IGMP V2_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V3_REPORT] = "SXD_IGMP_V3_REPORT", /**< ETHERNET L2 IGMP V3_REPORT */
    [SXD_TRAP_ID_ETH_L2_IGMP_TYPE_V2_LEAVE] = "SXD_IGMP_V2_LEAVE", /**< ETHERNET L2 IGMP V2_LEAVE */
    [SXD_TRAP_ID_ETH_L2_UDLD] = "SXD_UDLD",               /**< ETHERNET UDLD */
    [SXD_TRAP_ID_ETH_L2_DHCP] = "SXD_DHCP",               /**< ETHERNET DHCP */
    [SXD_TRAP_ID_ETH_CONF_TYPE0] = "SXD_ETH_CONF_TYPE0",
    [SXD_TRAP_ID_ETH_CONF_TYPE1] = "SXD_ETH_CONF_TYPE1",
    [SXD_TRAP_ID_ETH_L2_PKT_SAMPLE] = "SXD_PACKET_SAMPLE",    /**< ETHERNET L2 PACKET_SAMPLING */
    [SXD_TRAP_ID_FDB_MISS] = "SXD_FDB_MISS",
    [SXD_TRAP_ID_FDB_MISMATCH] = "SXD_FDB_MISMATCH",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE0] = "SXD_ICMPV6_CONF_TYPE0",
    [SXD_TRAP_ID_ICMPV6_CONF_TYPE1] = "SXD_ICMPV6_CONF_TYPE1",
    [SXD_TRAP_ID_OVERLAY_ICMPV6_CONF_TYPE] = "SXD_OVERLAY_ICMPV6_CONF_TYPE",
    [SXD_TRAP_ID_RARP_OPCODES] = "SXD_RARP_OPCODES",       /**< ETHERNET L2 RARP OPCODES */

    /* Telemetry threshold crossing */
    [SXD_TRAP_ID_SB_CONG_TX_PORT] = "SXD_SB_CONG_TX_PORT",

    /* ECN */
    [SXD_TRAP_ID_DECAP_ECN0] = "SXD_DECAP_ECN0",                /**< NVE/IPinIP/MPLS ECN0 */
    [SXD_TRAP_ID_DECAP_ECN1] = "SXD_DECAP_ECN1",                /**< NVE/IPinIP/MPLS ECN1 */

    /* Router */
    [SXD_TRAP_ID_ARP_REQUEST] = "SXD_ARP_REQUEST",               /**< ARP REQUEST */
    [SXD_TRAP_ID_ARP_RESPONSE] = "SXD_ARP_RESPONSE",              /**< ARP RESPONSE */
    [SXD_TRAP_ID_ETH_L3_MTUERROR] = "SXD_L3_MTUERROR",              /**< Packet exceed router interface MTU */
    [SXD_TRAP_ID_ETH_L3_TTLERROR] = "SXD_L3_TTLERROR",              /**< Time To Live (TTL, Expired */
    [SXD_TRAP_ID_ETH_L3_LBERROR] = "SXD_L3_LBERROR",
    [SXD_TRAP_ID_OSPF] = "SXD_OSPF",
    [SXD_TRAP_ID_RIP_V1] = "SXD_RIP_V1",
    [SXD_TRAP_ID_RIP_V2] = "SXD_RIP_V2",
    [SXD_TRAP_ID_PIM] = "SXD_PIM",
    [SXD_TRAP_ID_VRRP] = "SXD_VRRP",
    [SXD_TRAP_ID_VRRP_IPV6] = "SXD_VRRP_IPV6",
    [SXD_TRAP_ID_RESERVED_MC] = "SXD_RESERVED_MC",
    [SXD_TRAP_ID_IPBC] = "SXD_IPBC",
    [SXD_TRAP_ID_ETH_L3_RPF] = "SXD_L3_RPF",
    [SXD_TRAP_ID_ETH_L3_ASSERT] = "SXD_L3_ASSERT",
    [SXD_TRAP_ID_IP2ME] = "SXD_IP2ME",
    [SXD_TRAP_ID_RTR_INGRESS0] = "SXD_RTR_INGRESS0",
    [SXD_TRAP_ID_RTR_INGRESS1] = "SXD_RTR_INGRESS1",
    [SXD_TRAP_ID_RTR_INGRESS2] = "SXD_RTR_INGRESS2",
    [SXD_TRAP_ID_RTR_INGRESS3] = "SXD_RTR_INGRESS3",
    [SXD_TRAP_ID_RTR_EGRESS0] = "SXD_RTR_EGRESS0",
    [SXD_TRAP_ID_RTR_EGRESS1] = "SXD_RTR_EGRESS1",
    [SXD_TRAP_ID_RTR_EGRESS2] = "SXD_RTR_EGRESS2",
    [SXD_TRAP_ID_RTR_EGRESS3] = "SXD_RTR_EGRESS3",
    [SXD_TRAP_ID_HOST_MISS_IPV4] = "SXD_HOST_MISS_IPV4",
    [SXD_TRAP_ID_HOST_MISS_IPV6] = "SXD_HOST_MISS_IPV6",
    [SXD_TRAP_ID_BFD_IPV4] = "SXD_BFD_IPV4",
    [SXD_TRAP_ID_BFD_IPV6] = "SXD_BFD_IPV6",
    [SXD_TRAP_ID_SSH_IPV4] = "SXD_SSH_IPV4",
    [SXD_TRAP_ID_SSH_IPV6] = "SXD_SSH_IPV6",
    [SXD_TRAP_ID_PING_IPV4] = "SXD_PING_IPV4",
    [SXD_TRAP_ID_PING_IPV6] = "SXD_PING_IPV6",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV4] = "SXD_ROUTER_ALERT_IPV4",
    [SXD_TRAP_ID_ROUTER_ALERT_IPV6] = "SXD_ROUTER_ALERT_IPV6",
    [SXD_TRAP_ID_IPV4_DHCP] = "SXD_IPV4_DHCP",
    [SXD_TRAP_ID_IPV4_SNMP] = "SXD_SNMP_IPV4",
    [SXD_TRAP_ID_IPV6_SNMP] = "SXD_SNMP_IPV6",
    [SXD_TRAP_ID_ROUTER_ARPBC] = "SXD_ROUTER_ARPBC",
    [SXD_TRAP_ID_ROUTER_ARPUC] = "SXD_ROUTER_ARPUC",
    [SXD_TRAP_ID_ROUTER_RARP_OPCODES] = "SXD_ROUTER_RARP",

    /*IPv6 L3*/
    [SXD_TRAP_ID_IPV6_UNSPECIFIED_ADDRESS] = "SXD_IPV6_UNSPEC_ADDR",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_DST] = "SXD_IPV6_LINK_LOCAL_DST",
    [SXD_TRAP_ID_IPV6_LINK_LOCAL_SRC] = "SXD_IPV6_LINK_LOCAL_SRC",
    [SXD_TRAP_ID_IPV6_ALL_NODES_LINK] = "SXD_IPV6_ALL_NODES_LINK",
    [SXD_TRAP_ID_IPV6_OSPF] = "SXD_IPV6_OSPF",
    [SXD_TRAP_ID_IPV6_DHCP] = "SXD_IPV6_DHCP",

    [SXD_TRAP_ID_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    [SXD_TRAP_ID_IPV6_ALL_ROUTERS_LINK] = "SXD_IPV6_ALL_ROUTERS_LINK",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_SOLICITATION] = "SXD_IPV6_ROUTER_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_ROUTER_ADVERTISEMENT] = "SXD_IPV6_ROUTER_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_SOLICITATION] = "SXD_IPV6_NEIGH_SOLICITATION",
    [SXD_TRAP_ID_L3_IPV6_NEIGHBOR_ADVERTISEMENT] = "SXD_IPV6_NEIGH_ADVERTISEMENT",
    [SXD_TRAP_ID_L3_IPV6_REDIRECTION] = "SXD_IPV6_REDIRECTION",

    /*IPv6 L2*/
    [SXD_TRAP_ID_IPV6_MLD_V1_V2] = "SXD_IPV6_MLD_V1_V2",
    [SXD_TRAP_ID_IPV6_MLD_V1_REPORT] = "SXD_IPV6_MLD_V1_REPORT",
    [SXD_TRAP_ID_IPV6_MLD_V1_DONE] = "SXD_IPV6_MLD_V1_DONE",
    [SXD_TRAP_ID_IPV6_MLD_V2_REPORT] = "SXD_IPV6_MLD_V2_REPORT",

    /* InfiniBand */
    [SXD_TRAP_ID_INFINIBAND_QP0] = "SXD_INFINIBAND_QP0",                         /**< IB QP0 */
    [SXD_TRAP_ID_INFINIBAND_QP1] = "SXD_INFINIBAND_QP1",                         /**< IB QP1 */
    [SXD_TRAP_ID_INFINIBAND_OTHER_QPS] = "SXD_INFINIBAND_OTHER_QPS",           /**< IB OTHERS */
    [SXD_TRAP_ID_INFINIBAND_EXTERNAL_SMA] = "SXD_INFINIBAND_EXTERNAL_SMA",      /**< IB External SMA */
    [SXD_TRAP_ID_INFINIBAND_IN_NV_ACCESS_REG] = "SXD_INFINIBAND_IN_NV_ACCESS_REG", /**< IB VS-MAD with ACCESS_REG with one of the NV Config registers */
    [SXD_TRAP_ID_INFINIBAND_IB_FMAD_RCV] = "SXD_INFINIBAND_IB_FMAD_RCV",     /**< IB VS-MAD with ACCESS_REG with one of Config registers */
    [SXD_TRAP_ID_INFINIBAND_RESET_CMD] = "SXD_INFINIBAND_RESET_CMD",       /**< IB RESET CMD */

    /* MPLS */
    [SXD_TRAP_ID_MPLS_ILM_MISS] = "SXD_MPLS_ILM_MISS",
    [SXD_TRAP_ID_MPLS_LDP] = "SXD_MPLS_LDP",
    [SXD_TRAP_ID_MPLS_LB_LSP_PING] = "SXD_LB_LSP_PING",
    [SXD_TRAP_ID_MPLS_ILM0] = "SXD_MPLS_ILM0",
    [SXD_TRAP_ID_MPLS_ILM1] = "SXD_MPLS_ILM1",
    [SXD_TRAP_ID_MPLS_NHLFE0] = "SXD_MPLS_NHLFE0",
    [SXD_TRAP_ID_MPLS_NHLFE1] = "SXD_MPLS_NHLFE1",

    /* BGP */
    [SXD_TRAP_ID_IPV4_BGP] = "SXD_IPV4_BGP",
    [SXD_TRAP_ID_IPV6_BGP] = "SXD_IPV6_BGP",

    /* SPAN */
    [SXD_TRAP_ID_MIRROR] = "SXD_TRAP_ID_MIRROR",

    /* Tunneling */
    [SXD_TRAP_ID_DECAP_ENCAP] = "SXD_DECAP_ENCAP",
    [SXD_TRAP_ID_IPIP_DECAP_ERROR] = "SXD_IPIP_DECAP_ERROR",
    [SXD_TRAP_ID_IPIP_ERROR] = "SXD_IPIP_ERROR",
    [SXD_TRAP_ID_NVE_DECAP_IGMP] = "SXD_NVE_DECAP_IGMP",
    [SXD_TRAP_ID_NVE_DECAP_ARP] = "SXD_NVE_DECAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_TAG_ERROR] = "SXD_NVE_DECAP_TAG_ERROR",
    [SXD_TRAP_ID_NVE_IPV4_DHCP] = "SXD_NVE_IPV4_DHCP",
    [SXD_TRAP_ID_NVE_IPV6_DHCP] = "SXD_NVE_IPV6_DHCP",
    [SXD_TRAP_ID_NVE_DECAP_FRAG_ERROR] = "SXD_NVE_DECAP_FRAG_ERROR",
    [SXD_TRAP_ID_NVE_ENCAP_ARP] = "SXD_NVE_ENCAP_ARP",
    [SXD_TRAP_ID_NVE_DECAP_ETH] = "SXD_NVE_DECAP_ETH",
    [SXD_TRAP_ID_NVE_DECAP_MLD] = "SXD_NVE_DECAP_MLD",

    /* Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET] = "SXD_DISCARD_ING_PACKET",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH] = "SXD_DISCARD_ING_SWITCH",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH] = "SXD_DISCARD_LOOKUP_SWITCH",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER] = "SXD_DISCARD_ING_ROUTER",
    [SXD_TRAP_ID_DISCARD_ING_LSR] = "SXD_DISCARD_ING_LSR",
    [SXD_TRAP_ID_DISCARD_ROUTER] = "SXD_DISCARD_ROUTER",
    [SXD_TRAP_ID_DISCARD_LSR] = "SXD_DISCARD_LSR",
    [SXD_TRAP_ID_DISCARD_DEC] = "SXD_DISCARD_DEC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH] = "SXD_DISCARD_OVERLAY_SWITCH",
    [SXD_TRAP_ID_DISCARD_ISOLATION] = "SXD_DISCARD_ISOLATION",
    [SXD_TRAP_ID_DISCARD_NON_ROUTED] = "SXD_DISCARD_NON_ROUTED",
    [SXD_TRAP_ID_DISCARD_EGR_LSR] = "SXD_DISCARD_EGR_LSR",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE] = "SXD_DISCARD_MC_SCOPE",
    [SXD_TRAP_ID_DISCARD_ROUTER2] = "SXD_DISCARD_ROUTER2",
    [SXD_TRAP_ID_DISCARD_ROUTER3] = "SXD_DISCARD_ROUTER3",
    [SXD_TRAP_ID_DISCARD_LSR2] = "SXD_DISCARD_LSR2",
    [SXD_TRAP_ID_DISCARD_LSR3] = "SXD_DISCARD_LSR3",

    /* Extended Discards */
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_MC] = "SXD_DISCARD_ING_PACKET_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_SMAC_DMAC] = "SXD_DISCARD_ING_PACKET_SMAC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_PACKET_RSV_MAC] = "SXD_DISCARD_ING_PACKET_RSV_MAC",

    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VTAG_ALLOW] = "SXD_DISCARD_ING_SWITCH_VTAG_ALLOW",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_VLAN] = "SXD_DISCARD_ING_SWITCH_VLAN",
    [SXD_TRAP_ID_DISCARD_ING_SWITCH_STP] = "SXD_DISCARD_ING_SWITCH_STP",

    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_UC] = "SXD_DISCARD_LOOKUP_SWITCH_UC",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_MC_NULL] = "SXD_DISCARD_LOOKUP_SWITCH_MC_NULL",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_LB] = "SXD_DISCARD_LOOKUP_SWITCH_LB",
    [SXD_TRAP_ID_DISCARD_LOOKUP_SWITCH_NO_PORTS] = "SXD_DISCARD_LOOKUP_SWITCH_NO_PORTS",

    [SXD_TRAP_ID_DISCARD_ING_ROUTER_NO_HDR] = "SXD_DISCARD_ING_ROUTER_NO_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_UC_DIP_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LB] = "SXD_DISCARD_ING_ROUTER_DIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_MC] = "SXD_DISCARD_ING_ROUTER_SIP_MC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_CLASS_E] = "SXD_DISCARD_ING_ROUTER_SIP_CLASS_E",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LB] = "SXD_DISCARD_ING_ROUTER_SIP_LB",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_UNSP] = "SXD_DISCARD_ING_ROUTER_SIP_UNSP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_IP_HDR] = "SXD_DISCARD_ING_ROUTER_IP_HDR",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_MC_DMAC] = "SXD_DISCARD_ING_ROUTER_MC_DMAC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_DIP] = "SXD_DISCARD_ING_ROUTER_SIP_DIP",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_BC] = "SXD_DISCARD_ING_ROUTER_SIP_BC",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LOCAL_NET] = "SXD_DISCARD_ING_ROUTER_DIP_LOCAL_NET",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_DIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_DIP_LINK_LOCAL",
    [SXD_TRAP_ID_DISCARD_ING_ROUTER_SIP_LINK_LOCAL] = "SXD_DISCARD_ING_ROUTER_SIP_LINK_LOCAL",

    [SXD_TRAP_ID_DISCARD_ING_LSR_NO_LABEL] = "SXD_DISCARD_ING_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_ING_LSR_UC_ET] = "SXD_DISCARD_ING_LSR_UC_ET",
    [SXD_TRAP_ID_DISCARD_ING_LSR_MC_DMAC] = "SXD_DISCARD_ING_LSR_MC_DMAC",

    [SXD_TRAP_ID_DISCARD_ROUTER_IRIF_EN] = "SXD_DISCARD_ROUTER_IRIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_EN] = "SXD_DISCARD_ROUTER_ERIF_EN",
    [SXD_TRAP_ID_DISCARD_ROUTER_ERIF_FWD] = "SXD_DISCARD_ROUTER_ERIF_FWD",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM4] = "SXD_DISCARD_ROUTER_LPM4",
    [SXD_TRAP_ID_DISCARD_ROUTER_LPM6] = "SXD_DISCARD_ROUTER_LPM6",

    [SXD_TRAP_ID_DISCARD_LSR_MIN_LABEL] = "SXD_DISCARD_LSR_MIN_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_MAX_LABEL] = "SXD_DISCARD_LSR_MAX_LABEL",
    [SXD_TRAP_ID_DISCARD_LSR_LB] = "SXD_DISCARD_LSR_LB",

    [SXD_TRAP_ID_DISCARD_DEC_PKT] = "SXD_DISCARD_DEC_PKT",
    [SXD_TRAP_ID_DISCARD_DEC_DIS] = "SXD_DISCARD_DEC_DIS",

    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_MC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_MC",
    [SXD_TRAP_ID_DISCARD_OVERLAY_SWITCH_SMAC_DMAC] = "SXD_DISCARD_OVERLAY_SWITCH_SMAC_DMAC",

    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_LABEL] = "SXD_DISCARD_EGR_LSR_NO_LABEL",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_NO_IP] = "SXD_DISCARD_EGR_LSR_NO_IP",
    [SXD_TRAP_ID_DISCARD_EGR_LSR_PHP_NO_IP] = "SXD_DISCARD_EGR_LSR_PHP_NO_IP",

    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_0] = "SXD_DISCARD_MC_SCOPE_IPV6_0",
    [SXD_TRAP_ID_DISCARD_MC_SCOPE_IPV6_1] = "SXD_DISCARD_MC_SCOPE_IPV6_1",

    /* SWITCHX SDK EVENTS */
    [SXD_TRAP_ID_SIGNAL] = "SXD_SW_EV_SIGNAL",             /**< signal trap for SDK internal use */
    [SXD_TRAP_ID_NEW_DEVICE_ADD] = "SXD_SW_EV_NEW_DEVICE_ADD",                  /**< device add event */
    [SXD_TRAP_ID_MAC_LEARNING_EVENT] = "SXD_SW_EV_MAC_LEARNING_EVENT",              /**< mac learning event */
    [SXD_TRAP_ID_MAC_AGING_EVENT] = "SXD_SW_EV_MAC_AGING_EVENT",                 /**< mac aging event */
    [SXD_TRAP_ID_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NEED_TO_RESOLVE_ARP",             /**< need to resolve ARP  */
    [SXD_TRAP_ID_NO_NEED_TO_RESOLVE_ARP] = "SXD_SW_EV_NO_NEED_TO_RESOLVE_ARP",          /**< no need to resolve ARP  */
    [SXD_TRAP_ID_FDB_EVENT] = "SXD_SW_EV_FDB_EVENT",                       /**< FDB event */
    [SXD_TRAP_ID_RM_SDK_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_SDK_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_RM_HW_TABLE_THRESHOLD_EVENT] = "SXD_SW_EV_RM_HW_TABLE_THRESHOLD_EVENT",
    [SXD_TRAP_ID_FDB_SRC_MISS] = "SXD_SW_EV_FDB_SRC_MISS",                    /**< FDB SRC MISS trap */
    [SXD_TRAP_ID_ROUTER_NEIGH_ACTIVITY] = "SXD_SW_EV_ROUTER_NEIGH_ACTIVITY",
    [SXD_TRAP_ID_ASYNC_API_COMPLETE_EVENT] = "SXD_SW_EV_ASYNC_API_COMPLETE_EVENT",
    [SXD_TRAP_ID_ROUTER_MC_ACTIVITY] = "SXD_SW_EV_ROUTER_MC_ACTIVITY",              /**< router mc activity */
    [SXD_TRAP_ID_FDB_IP_ADDR_ACTIVITY] = "SXD_SW_EV_FDB_IP_ADDR_ACTIVITY",            /**< fdb ip addr activity */
    [SXD_TRAP_ID_TRANSACTION_ERROR] = "SXD_SW_EV_TRANSACTION_ERROR",               /**< error in transaction mode */
    [SXD_TRAP_ID_BFD_TIMEOUT_EVENT] = "SXD_SW_EV_BFD_TIMEOUT_EVENT",
    [SXD_TRAP_ID_BFD_PACKET_EVENT] = "SXD_SW_EV_BFD_PACKET_EVENT",

    /*User defined trap ID*/
    [SXD_TRAP_ID_IP2ME_CUSTOM0] = "SXD_IP2ME_CUSTOM0",
    [SXD_TRAP_ID_IP2ME_CUSTOM1] = "SXD_IP2ME_CUSTOM1",

    [SXD_TRAP_ID_MAX + 1] = "SXD_UNKNOWN",                               /**< MAXIMUM TRAP ID */
};

#define SXD_TRAP_ID_STR_SIZE (sizeof(sxd_trap_id_str_s) / sizeof(sxd_trap_id_str_s[0]))

/************************************************
 *  Function implementations
 ***********************************************/
const char * trap_id_str(u16 trap_id)
{
    if (trap_id == NUM_HW_SYNDROMES) {
        return TRAP_ANY_STR;
    } else if ((trap_id >= SXD_TRAP_ID_ACL_MIN) && (trap_id <= SXD_TRAP_ID_ACL_MAX)) {
        return TRAP_ACL_OR_ROUTER_STR;
    } else {
        return (trap_id < SXD_TRAP_ID_STR_SIZE && sxd_trap_id_str_s[trap_id] ?
                sxd_trap_id_str_s[trap_id] : TRAP_UNKNOWN_STR);
    }
}

static void print_header(struct seq_file *m, const char* header)
{
    seq_printf(m, "\n..................................................\n");
    seq_printf(m, header);
    seq_printf(m, "\n..................................................\n");
}

static void print_listener(struct seq_file                 *m,
                           u16                              synd,
                           struct listener_entry           *listener,
                           struct listener_port_vlan_entry *port_vlan_listener)
{
    static char handler_name[KSYM_SYMBOL_LEN] = "";
    static char uc_name[DBG_DUMP_BUFF_SIZE] = "";
    static char type_name[DBG_DUMP_BUFF_SIZE] = "";
    static char type_crit[DBG_DUMP_BUFF_SIZE] = "";
    static char reg_key_name[DBG_DUMP_BUFF_SIZE] = "";
    char       *end;

    memset(handler_name, 0, sizeof(handler_name));
    memset(uc_name, 0, sizeof(uc_name));
    memset(type_name, 0, sizeof(type_name));
    memset(type_crit, 0, sizeof(type_crit));
    memset(reg_key_name, 0, sizeof(reg_key_name));

    sprint_symbol(handler_name, (unsigned long)listener->handler);
    end = strchr(handler_name, '+');
    if (end) {
        *end = '\0';
    }

    if (strstr(handler_name, "sx_netdev_handle_pude_event")) {
        strcpy(uc_name, "PUDE");
    } else if (strstr(handler_name, "sx_ib_handle_rx_pkt")
               || strstr(handler_name, "sx_ib_rpa_handle_rx_pkt")
               || strstr(handler_name, "sx_ib_tca_handle_rx_pkt")
               || strstr(handler_name, "sx_netdev_handle_global_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_cq_handler")) {
        strcpy(uc_name, "FD");
    } else if (strstr(handler_name, "sx_netdev_handle_rx_pkt")) {
        strcpy(uc_name, "L3_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_log_port_rx_pkt")) {
        strcpy(uc_name, "LOG_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_netdev_phy_port_rx_pkt")) {
        strcpy(uc_name, "PHY_PORT_NETDEV");
    } else if (strstr(handler_name, "sx_l2_tunnel_handler")) {
        strcpy(uc_name, "L2_TUNNEL");
    } else {
        strncpy(uc_name, handler_name, sizeof(uc_name) - 1);
    }

    switch (listener->listener_type) {
    case L2_TYPE_DONT_CARE:
        strcpy(type_name, "Don't Care");
        if (listener->critireas.dont_care.sysport != SYSPORT_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", sysport %d", listener->critireas.dont_care.sysport);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_IB:
        strcpy(type_name, "IB");
        if (listener->critireas.ib.qpn != QPN_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", qpn %d", listener->critireas.ib.qpn);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_ETH:
        strcpy(type_name, "ETH");
        if (listener->critireas.eth.ethtype != ETHTYPE_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", ethtype 0x%x", listener->critireas.eth.ethtype);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.dmac != DMAC_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", dmac 0x%llx", listener->critireas.eth.dmac);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.emad_tid != TID_DONT_CARE_VALUE) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", emad_tid 0x%x", listener->critireas.eth.emad_tid);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_rp != IS_RP_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_rp %d", listener->critireas.eth.from_rp);
            strcat(type_name, type_crit);
        }
        if (listener->critireas.eth.from_bridge != IS_BRIDGE_DONT_CARE_E) {
            snprintf(type_crit, DBG_DUMP_BUFF_SIZE, ", from_bridge %d", listener->critireas.eth.from_bridge);
            strcat(type_name, type_crit);
        }
        break;

    case L2_TYPE_FC:
        strcpy(type_name, "FC");
        break;

    default:
        strcpy(type_name, "NA");
    }

    switch (port_vlan_listener->match_crit) {
    case PORT_VLAN_MATCH_GLOBAL:
        strcpy(reg_key_name, "Global");
        break;

    case PORT_VLAN_MATCH_PORT_VALID:
        snprintf(reg_key_name, DBG_DUMP_BUFF_SIZE, "Sysport %d", port_vlan_listener->sysport);
        break;

    case PORT_VLAN_MATCH_LAG_VALID:
        snprintf(reg_key_name, DBG_DUMP_BUFF_SIZE, "LID %d", port_vlan_listener->lag_id);
        break;

    case PORT_VLAN_MATCH_VLAN_VALID:
        snprintf(reg_key_name, DBG_DUMP_BUFF_SIZE, "Vlan %d", port_vlan_listener->vlan);
        break;

    default:
        strcpy(reg_key_name, "NA");
    }

    seq_printf(m, "%-40s|%-8d| %-13s| %-20s| %-30s| %llu\n",
               trap_id_str(synd),
               synd,
               reg_key_name,
               uc_name,
               type_name,
               listener->rx_pkts);
}

static int sx_dbg_trap_reg_dump_proc_show(struct seq_file *m, void *v)
{
    struct listener_entry           *listener;
    struct listener_port_vlan_entry *port_vlan_listener;
    struct list_head                *pos;
    struct list_head                *port_vlan_pos;
    unsigned long                    flags;
    u16                              synd = 0;

    print_header(m, "Trap Registration");


    seq_printf(m, "%-40s|%-8s| %-13s| %-20s| %-30s| %s\n",
               "Trap Name", "Trap ID", "Reg Key", "User Channel", "Type", "RX packets");

    seq_printf(m, "--------------------------------------------"
               "--------------------------------------------"
               "--------------------------------------------\n");
    spin_lock_irqsave(&sx_glb.listeners_lock, flags);
    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        if (!list_empty(&sx_glb.listeners_db[synd].list)) {
            list_for_each(port_vlan_pos, &sx_glb.listeners_db[synd].list) {
                port_vlan_listener = list_entry(port_vlan_pos, struct listener_port_vlan_entry, list);
                list_for_each(pos, &(port_vlan_listener->listener.list)) {
                    listener = list_entry(pos, struct listener_entry, list);
                    print_listener(m, synd, listener, port_vlan_listener);
                }
            }
        }
    }
    spin_unlock_irqrestore(&sx_glb.listeners_lock, flags);

    return 0;
}


static int sx_dbg_unconsumed_pkt_dump_proc_show(struct seq_file *m, void *v)
{
    u16 synd = 0;
    u64 total_cnt = 0;
    int pkt_ind = 0;

    print_header(m, "Unconsumed packets");

    seq_printf(m, "%-40s|%-8s| %s\n", "Trap Name",
               "Trap ID", "Total Unconsumed packets");
    seq_printf(m, "---------------------------------------"
               "---------------------------------------\n");
    for (synd = 0; synd < NUM_HW_SYNDROMES + 1; synd++) {
        total_cnt = 0;
        for (pkt_ind = 0; pkt_ind < PKT_TYPE_NUM; pkt_ind++) {
            total_cnt = total_cnt + sx_glb.stats.rx_unconsumed_by_synd[synd][pkt_ind];
        }
        if (total_cnt > 0) {
            seq_printf(m, "%-40s|%-8d| %llu\n", trap_id_str(synd), synd, total_cnt);
        }
    }

    return 0;
}


static int sx_dbg_cq_dump_proc_show(struct seq_file *m, void *v)
{
    u8                           cqn = 0;
    unsigned long                flags;
    struct sx_cq_table          *cq_table;
    long                         now = jiffies;
    int                          last_time_armed, last_time_event;
    struct sx_dev               *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    struct cpu_traffic_priority *cpu_traffic_prio;
    struct sx_priv              *priv;
    u32                          diff;

    if (!dev) {
        return 0;
    }

    priv = sx_priv(dev);
    if (!priv) {
        return 0;
    }

    cq_table = &priv->cq_table;
    if (!cq_table) {
        return 0;
    }

    cpu_traffic_prio = &cq_table->cpu_traffic_prio;

    print_header(m, "CQ dump");

    seq_printf(m, "\n\n");

    if (atomic_read(&cpu_traffic_prio->high_prio_cq_in_load) == 1) {
        seq_printf(m, "*** CPU is under storm traffic! ***\n");
    }

    seq_printf(m,
               "%-14s | %-4s | %-8s | %-8s | %-5s | %-8s | %-6s | %-7s | %-10s | %-10s\n",
               "CQ #",
               "CPU ",
               "cons_idx",
               "diff",
               "nent",
               "cons_idx",
               "refcnt",
               "CQE    ",
               "Last time  ",
               "Last time  ");

    seq_printf(m,
               "%-14s | %-4s | %-8s | %-8s | %-5s | %-8s | %-6s | %-7s | %-10s | %-10s\n",
               "    ",
               "prio",
               "        ",
               "    ",
               "    ",
               "modulo  ",
               "      ",
               "version",
               "armed (sec)",
               "event (sec)");

    seq_printf(m, "===================================================================="
               "======================================\n");

    spin_lock_irqsave(&cq_table->lock, flags);
    for (cqn = 0; cqn < dev->dev_cap.max_num_cqs; cqn++) {
        if (cqn == NUMBER_OF_SDQS) {
            seq_printf(m, "------------------------------------------------------------------"
                       "--------------------------------------\n");
        }

        if (cq_table->cq[cqn] != NULL) {
            last_time_armed = (priv->cq_last_time_armed[cqn] != 0) ?
                              (jiffies_to_msecs(now - priv->cq_last_time_armed[cqn]) / 1000) : 0;

            last_time_event = (priv->cq_last_time_event[cqn] != 0) ?
                              (jiffies_to_msecs(now - priv->cq_last_time_event[cqn]) / 1000) : 0;

            if (cq_table->cq[cqn]->cons_index > cq_table->cq[cqn]->cons_index_snapshot) {
                diff = cq_table->cq[cqn]->cons_index - cq_table->cq[cqn]->cons_index_snapshot;
            } else {
                diff = 0xffffffff - cq_table->cq[cqn]->cons_index_snapshot + 1 + cq_table->cq[cqn]->cons_index;
            }

            cq_table->cq[cqn]->cons_index_snapshot = cq_table->cq[cqn]->cons_index;

            seq_printf(m, "CQ %02u (%s %02u) | %-4s | %-8u | %-8u | %-5u | %-8u | %-6u | %-7u | %-10u | %-10u\n",
                       cqn, ((cqn < NUMBER_OF_SDQS) ? "SDQ" : "RDQ"),
                       ((cqn < NUMBER_OF_SDQS) ? cqn : cqn - NUMBER_OF_SDQS),
                       (sx_bitmap_test(&cpu_traffic_prio->high_prio_cq_bitmap, cqn) ? "high" : "low"),
                       cq_table->cq[cqn]->cons_index,
                       diff,
                       cq_table->cq[cqn]->nent,
                       (cq_table->cq[cqn]->cons_index & (cq_table->cq[cqn]->nent - 1)),
                       atomic_read(&cq_table->cq[cqn]->refcount),
                       cq_table->cq[cqn]->cqe_version,
                       jiffies_to_msecs(now - priv->cq_last_time_armed[cqn]) / 1000,
                       jiffies_to_msecs(now - priv->cq_last_time_event[cqn]) / 1000);
        }
    }
    spin_unlock_irqrestore(&cq_table->lock, flags);

    return 0;
}


static struct proc_info * __name_to_info(const char *name)
{
    struct proc_info *iter;

    if (!name) {
        return NULL;
    }

    list_for_each_entry(iter, &__proc_list, list) {
        if (strcmp(name, iter->name) == 0) {
            return iter;
        }
    }

    return NULL;
}


static int sx_dbg_ber_monitor_dump_proc_show(struct seq_file *m, void *v)
{
    u8             i = 0;
    unsigned long  flags;
    const char   * state_2_str[] = {"Disable", "Normal", "Warning", "Alarm"};
    const char   * bitmask_2_str[] = {"Disable", "N", "W", "NW", "A", "AN", "AW", "ANW"};
    struct sx_dev *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return -ENODEV;
    }

    print_header(m, "BER monitor dump");

    seq_printf(m, "%-11s| %-11s| %-11s\n",
               "local_port", "bitmask", "state");
    seq_printf(m, "-------------------------------------\n");
    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
        if (sx_priv(dev)->port_ber_monitor_bitmask[i] != 0) {
            if ((sx_priv(dev)->port_ber_monitor_bitmask[i] < 8)
                && (sx_priv(dev)->port_ber_monitor_state[i] < 4)) {
                seq_printf(m, "%-11d| %-11s| %-11s\n",
                           i,
                           bitmask_2_str[sx_priv(dev)->port_ber_monitor_bitmask[i]],
                           state_2_str[sx_priv(dev)->port_ber_monitor_state[i]]);
            } else {
                seq_printf(m, "%-11d| %-11d| %-11d\n",
                           i,
                           sx_priv(dev)->port_ber_monitor_bitmask[i],
                           sx_priv(dev)->port_ber_monitor_state[i]);
            }
        }
    }
    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    return 0;
}


static int __sx_dbg_dump_proc_open(struct inode *inode, struct file *file)
{
    const char      * name = (const char*)PDE_DATA(inode);
    struct proc_info *iter = __name_to_info(name);

    if (!iter) {
        printk(KERN_ERR "could not find proc file '%s' information\n", name);
        return -ENOENT;
    }

    return single_open_size(file, iter->show_cb, NULL, iter->size_cb ? iter->size_cb() : SEQ_FILE_SIZE);
}


static int sx_dbg_tele_thrs_dump_proc_show(struct seq_file *m, void *v)
{
    u8             i = 0;
    unsigned long  flags;
    struct sx_dev *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return -ENODEV;
    }

    print_header(m, "TELE threshold dump");

    seq_printf(m, "%-11s| %-11s| %s\n", "local_port", "state", "tc_vec");
    seq_printf(m, "-------------------------------------\n");
    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    for (i = 0; i < MAX_PHYPORT_NUM + 1; i++) {
        if (sx_priv(dev)->tele_thrs_state[i]) {
            seq_printf(m, "%-11u| %-11u| %llx\n",
                       i,
                       sx_priv(dev)->tele_thrs_state[i],
                       sx_priv(dev)->tele_thrs_tc_vec[i]);
        }
    }
    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    return 0;
}


void __sx_dbg_dump_monitor_rdq(struct seq_file *m, struct sx_dev *dev, int rdq_n)
{
    struct sx_priv     *priv = sx_priv(dev);
    struct sx_dq_table *rdq_table = &priv->rdq_table;
    struct sx_dq       *rdq;

    if (rdq_table == NULL) {
        printk(KERN_INFO "rdq table is empty \n");
        return;
    }

    if (rdq_n > (dev->dev_cap.max_num_rdqs - 1)) {
        printk(KERN_INFO "rdq_n %d is out of range [0..%d]\n",
               rdq_n, dev->dev_cap.max_num_rdqs);
        return;
    }


    if (!rdq_table->dq[rdq_n]) {
        return;
    }

    rdq = rdq_table->dq[rdq_n];

    if (!rdq->is_monitor) {
        return;
    }

    seq_printf(m, "rdq %d data:  is_mon:%d, rx_cnt:%u, rx_start:%u, cpu_tc:%d \n",
               rdq_n,
               rdq->is_monitor,                  /* rdq is cyclic monitor rdq. non valid for sdq */
               rdq->mon_rx_count,
               rdq->mon_rx_start,
               rdq->cpu_tclass);
}

int sx_dbg_dump_monitor_rdq_show(struct seq_file *m, void *v)
{
    int                 rdq_n;
    struct sx_priv     *priv = NULL;
    struct sx_dq_table *rdq_table = NULL;
    struct sx_dev      *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;

    if (!dev) {
        return -ENODEV;
    }

    priv = sx_priv(dev);
    rdq_table = &priv->rdq_table;

    for (rdq_n = 0; rdq_n < dev->dev_cap.max_num_rdqs; rdq_n++) {
        __sx_dbg_dump_monitor_rdq(m, dev, rdq_n);
    }

    return 0;
}

int sx_dbg_dump_fid_to_hwfid_show(struct seq_file *m, void *v)
{
    u16             i = 0;
    u16             fid = 0;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    unsigned long   flags;

    if (!dev) {
        return -ENODEV;
    }

    priv = sx_priv(dev);

    print_header(m, "FID to HW_FID mapping dump");

    seq_printf(m, "%-7s| %-7s| %-7s\n", "#", "FID", "HW_FID");
    seq_printf(m, "-----------------------\n");

    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    i = 0;
    for (fid = 0; fid < MAX_FIDS_NUM; fid++) {
        if (priv->fid_to_hwfid[fid] != INVALID_HW_FID_ID) {
            i++;
            seq_printf(m, "%-7u| %-7u| %-7u\n",
                       i,
                       fid,
                       priv->fid_to_hwfid[fid]);
        }
    }

    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    return 0;
}

int sx_dbg_dump_rif_to_hwfid_show(struct seq_file *m, void *v)
{
    u16             i = 0;
    u16             rif_id = 0;
    struct sx_priv *priv = NULL;
    struct sx_dev  *dev = sx_glb.sx_dpt.dpt_info[DEFAULT_DEVICE_ID].sx_pcie_info.sx_dev;
    unsigned long   flags;

    if (!dev) {
        return -ENODEV;
    }

    priv = sx_priv(dev);

    print_header(m, "RIF to HW_FID mapping dump");

    seq_printf(m, "%-7s| %-7s| %-7s\n", "#", "RIF", "HW_FID");
    seq_printf(m, "-----------------------\n");

    spin_lock_irqsave(&sx_priv(dev)->db_lock, flags);

    i = 0;
    for (rif_id = 0; rif_id < MAX_RIFS_NUM; rif_id++) {
        if (priv->rif_id_to_hwfid[rif_id] != INVALID_HW_FID_ID) {
            i++;
            seq_printf(m, "%-7u| %-7u| %-7u\n",
                       i,
                       rif_id,
                       priv->fid_to_hwfid[rif_id]);
        }
    }

    spin_unlock_irqrestore(&sx_priv(dev)->db_lock, flags);

    return 0;
}

int sx_dbg_dump_proc_fs_register(const char *name, dbg_dump_proc_show_cb_t show_cb, dbg_dump_proc_size_cb_t size_cb)
{
    static const struct file_operations __sx_dbg_dump_proc_handler = {
        .owner = THIS_MODULE,
        .open = __sx_dbg_dump_proc_open,
        .read = seq_read,
        .llseek = seq_lseek,
        .release = single_release
    };
    struct proc_dir_entry              *pde;
    struct proc_info                   *proc_info = NULL;
    int                                 err;

    if (!name || !show_cb) {
        printk(KERN_ERR "proc file name is empty or no show handler\n");
        return -EINVAL;
    }

    mutex_lock(&__proc_list_lock);

    if (__name_to_info(name)) {
        printk(KERN_ERR "proc file %s already exists\n", name);
        err = -EEXIST;
        goto error;
    }

    err = -ENOMEM;

    proc_info = kmalloc(sizeof(struct proc_info), GFP_KERNEL);
    if (proc_info == NULL) {
        printk(KERN_WARNING "create info for proc %s failed\n", name);
        goto error;
    }

    proc_info->name = kmalloc(strlen(name) + 1, GFP_KERNEL);
    if (proc_info->name == NULL) {
        printk(KERN_WARNING "allocate name of info for proc %s failed\n", name);
        goto error;
    }

    strcpy(proc_info->name, name);

    pde = proc_create_data(name,
                           S_IFREG | S_IRUGO,
                           __root_dir,
                           &__sx_dbg_dump_proc_handler,
                           (void*)proc_info->name);
    if (pde == NULL) {
        printk(KERN_WARNING "create proc %s failed\n", name);
        goto error;
    }

    INIT_LIST_HEAD(&proc_info->list);
    proc_info->show_cb = show_cb;
    proc_info->size_cb = size_cb;

    list_add(&proc_info->list, &__proc_list);
    printk(KERN_INFO "create proc %s succeeded\n", name);

    err = 0;

out:
    mutex_unlock(&__proc_list_lock);
    return err;

error:
    if (proc_info) {
        if (proc_info->name) {
            kfree(proc_info->name);
        }

        kfree(proc_info);
    }

    goto out;
}

int sx_dbg_ptp_dump_proc_show(struct seq_file *m, void *v);


void __sx_dbg_dump_proc_fs_unregister(struct proc_info *proc_info)
{
    list_del(&proc_info->list);
    remove_proc_entry(proc_info->name, __root_dir);
    printk(KERN_INFO "remove proc %s succeeded\n", proc_info->name);
    kfree(proc_info->name);
    kfree(proc_info);
}


void sx_dbg_dump_proc_fs_unregister(const char *name)
{
    struct proc_info *proc_info;

    mutex_lock(&__proc_list_lock);

    proc_info = __name_to_info(name);
    if (proc_info == NULL) {
        printk(KERN_ERR "proc file %s does not exist\n", name);
    } else {
        __sx_dbg_dump_proc_fs_unregister(proc_info);
    }

    mutex_unlock(&__proc_list_lock);
}


int __init sx_dbg_dump_proc_fs_init(void)
{
    const char *proc_dir_name = SX_DBG_DUMP_PROC_DIR;

    sx_dbg_dump_proc_registered = 0;
    if (sx_dbg_dump_proc_registered) {
        return -EEXIST;
    }

    mutex_init(&__proc_list_lock);

    /* Create dbg dump proc directory */
    __root_dir = proc_mkdir(proc_dir_name, NULL);
    if (__root_dir == NULL) {
        printk(KERN_WARNING "create proc dir %s failed\n", proc_dir_name);
        return -ENOMEM;
    }

    sx_dbg_dump_proc_registered = 1;

    sx_dbg_dump_proc_fs_register("trap_reg_dump", sx_dbg_trap_reg_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("unconsumed_pkt_dump", sx_dbg_unconsumed_pkt_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("cq_dump", sx_dbg_cq_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("ber_monitor_dump", sx_dbg_ber_monitor_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("tele_thrs_dump", sx_dbg_tele_thrs_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("ptp_dump", sx_dbg_ptp_dump_proc_show, NULL);
    sx_dbg_dump_proc_fs_register("monitor_rdq_dump", sx_dbg_dump_monitor_rdq_show, NULL);
    sx_dbg_dump_proc_fs_register("fid_to_hwfid_dump", sx_dbg_dump_fid_to_hwfid_show, NULL);
    sx_dbg_dump_proc_fs_register("rif_to_hwfid_dump", sx_dbg_dump_rif_to_hwfid_show, NULL);

    sx_core_counters_init();

    return 0;
}

void sx_dbg_dump_proc_fs_deinit(void)
{
    struct proc_info *iter, *tmp;

    if (sx_dbg_dump_proc_registered == 0) {
        return;
    }

    mutex_lock(&__proc_list_lock);

    list_for_each_entry_safe(iter, tmp, &__proc_list, list) {
        __sx_dbg_dump_proc_fs_unregister(iter);
    }

    mutex_unlock(&__proc_list_lock);

    /* Remove dbg dump proc directory */
    remove_proc_entry(SX_DBG_DUMP_PROC_DIR, NULL);
    sx_dbg_dump_proc_registered = 0;
}
